\subsection{Vector methods}

%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_new}: Construct new vector}

Creates a new vector with specified domain and size.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_new(GrB_Vector *v,
                                GrB_Type    d,
                                GrB_Index   nsize);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf v}] ({\sf INOUT}) On successful return, contains a handle
                                 to the newly created GraphBLAS vector.
    \item[{\sf d}] ({\sf IN})    The type corresponding to the domain of the 
                                 vector being created.  Can be one of the 
                                 predefined GraphBLAS types in 
                                 Table~\ref{Tab:PredefinedTypes}, or an existing 
                                 user-defined GraphBLAS type.
    \item[{\sf nsize}] ({\sf IN}) The size of the vector being created.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output vector 
    {\sf v} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The {\sf GrB\_Type} object has not 
    been initialized by a call to {\sf GrB\_Type\_new} (needed for user-defined types).
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf v} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_INVALID\_VALUE}] {\sf nsize} is zero or outside the range of the type {\sf GrB\_Index}.
\end{itemize}

\paragraph{Description}

Creates a new vector $\vector{v}$ of domain $\mathbf{D}({\sf d})$, size {\sf nsize}, 
and empty $\mathbf{L}(\vector{v})$. The method returns a handle to the new vector in {\sf v}.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created object will be overwritten. 

%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_dup}: Construct a copy of a GraphBLAS vector}

Creates a new vector with the same domain, size, and contents as another vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_dup(GrB_Vector       *w,
                                const GrB_Vector  u);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]  ({\sf INOUT}) On successful return, contains a handle
                                  to the newly created GraphBLAS vector.
    \item[{\sf u}]  ({\sf IN})    The GraphBLAS vector to be duplicated.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output vector 
    {\sf w} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf u}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf w} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Creates a new vector $\vector{w}$ of domain $\mathbf{D}({\sf u})$, size 
$\mathbf{size}({\sf u})$, and contents $\mathbf{L}({\sf u})$. The method returns a 
handle to the new vector in {\sf w}.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created object will be overwritten. 

%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_resize}: Resize a vector}

Changes the size of an existing vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_resize(GrB_Vector  w,
                                   GrB_Index   nsize);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}] ({\sf INOUT}) An existing Vector object that is being resized.
    \item[{\sf nsize}] ({\sf IN}) The new size of the vector. It can be smaller or larger than the current size.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output vector 
    {\sf w} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf w} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_INVALID\_VALUE}] {\sf nsize} is zero or outside the range of the type {\sf GrB\_Index}.
\end{itemize}

\paragraph{Description}

Changes the size of ${\sf w}$ to {\sf nsize}. The domain
$\mathbf{D}({\sf w})$ of vector ${\sf w}$ remains the same. The
contents $\mathbf{L}({\sf w})$ are modified as described below.

Let ${\sf w} = \langle \mathbf{D}({\sf w}), N, \mathbf{L}({\sf w})
\rangle$ when the method is called. When the method returns, ${\sf w}
= \langle \mathbf{D}({\sf w}), {\sf nsize}, \mathbf{L'}({\sf w})
\rangle$ where $\mathbf{L'}({\sf w}) = \{(i,w_i) : (i,w_i) \in
\mathbf{L}({\sf w}) \wedge (i < {\sf nsize})\}$. That is, all elements
of ${\sf w}$ with index greater than or equal to the new vector size
(${\sf nsize}$) are dropped.

%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_clear}: Clear a vector}

Removes all the elements (tuples) from a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_clear(GrB_Vector v);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf v}] ({\sf INOUT}) An existing GraphBLAS vector to clear.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output vector 
    {\sf v} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf v}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
\end{itemize}

\paragraph{Description}

Removes all elements (tuples) from an existing vector. After the call to
{\sf GrB\_Vector\_clear(v)}, 
$\mathbf{L}(\vector{v}) = \emptyset$. The size of the vector does not change. 


%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_size}: Size of a vector}

Retrieve the size of a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_size(GrB_Index        *nsize,
                                 const GrB_Vector  v);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf nsize}] ({\sf OUT}) On successful return, is set to the size 
                                   of the vector.
    \item[{\sf v}]     ({\sf IN})  An existing GraphBLAS vector being queried.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]   In blocking or non-blocking mode, the operation 
    completed successfully and the value of {\sf nsize} has been set.

    \item[{\sf GrB\_PANIC}]     Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf v}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf nsize} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Return $\mathbf{size}({\sf v})$ in {\sf nsize}.

%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_nvals}: Number of stored elements in a vector}
\label{Sec:Vector_nvals}

Retrieve the number of stored elements (tuples) in a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_nvals(GrB_Index        *nvals,
                                  const GrB_Vector  v);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf nvals}] ({\sf OUT}) On successful return, this is set to the number of 
                                   stored elements (tuples) in the vector.
    \item[{\sf v}]     ({\sf IN})  An existing GraphBLAS vector being queried.
\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully and the value of {\sf nvals} has been set. 

    \item[{\sf GrB\_PANIC}]    Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf v}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf nvals} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}


Return $\mathbf{nvals}({\sf v})$ in {\sf nvals}. This is the number of stored 
elements in vector {\sf v}, which is the size of $\mathbf{L}(\vector{v})$ (see 
Section~\ref{Sec:Vectors}).

%-----------------------------------------------------------------------------

\subsubsection{{\sf Vector\_build}: Store elements from tuples into a vector}
\label{Sec:Vector_build}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_build(GrB_Vector             w,
                                  const GrB_Index       *indices,
                                  const <type>          *values,
                                  GrB_Index              n,
                                  const GrB_BinaryOp     dup);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]       ({\sf INOUT}) An existing Vector object to store the result.
    \item[{\sf indices}] ({\sf IN}) Pointer to an array of indices. 
    \item[{\sf values}]  ({\sf IN}) Pointer to an array of scalars of a type that
                                     is compatible with the domain of vector {\sf w}.
    \item[{\sf n}]       ({\sf IN}) The number of entries contained in each array (the same for \arg{indices} and \arg{values}).
    \item[{\sf dup}]     ({\sf IN}) An associative and commutative binary operator 
    to apply when duplicate values for the same location are present in the input
    arrays. All three domains of {\sf dup} must be the same; hence
	    $dup=\langle D_{dup},D_{dup},D_{dup},\oplus \rangle$.
    If {\sf dup} is {\sf GrB\_NULL}, then duplicate locations will result in an error.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output vector 
    {\sf w} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  Either {\sf w} has not been 
    initialized by a call to {\sf by GrB\_Vector\_new} or 
    {\sf by GrB\_Vector\_dup}, or
    {\sf dup} has not been initialized by a call to {\sf by GrB\_BinaryOp\_new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf indices} or {\sf values} 
    pointer is {\sf NULL}.

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}] A value in {\sf indices} is outside 
    the allowed range for {\sf w}.
    
	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Either the domains of the GraphBLAS 
    binary operator {\sf dup} are not all the same, or the domains of 
    {\sf values} and {\sf w} are incompatible with each other or $D_{dup}$.
	
	\item[{\sf GrB\_OUTPUT\_NOT\_EMPTY}]    Output vector {\sf w} already contains valid tuples (elements).
	In other words, {\sf GrB\_Vector\_nvals(C)} returns a positive value.
    
    \item[{\sf GrB\_INVALID\_VALUE}] {\sf indices} contains a duplicate location
    and {\sf dup} is {\sf GrB\_NULL}.
\end{itemize}

\paragraph{Description}

If {\sf dup} is not {\sf GrB\_NULL}, an internal vector 
$\vector{\widetilde{w}} = \langle D_{dup},\mathbf{size}({\sf w}),\emptyset \rangle$ 
is created, which only differs from ${\sf w}$ in its domain; otherwise, 
$\vector{\widetilde{w}} = \langle \mathbf{D}({\sf w}),\mathbf{size}({\sf w}),\emptyset \rangle$.

Each tuple $\{ {\sf indices[k]}, {\sf values[k]}\}$, where $0\leq k < {\sf n}$, is a contribution to the output in the form of 
\[
\vector{\widetilde{w}}({\sf indices[k]}) = 
\begin{cases} 
(D_{dup})\, {\sf values[k]} & \text{ if {\sf dup} $\neq$ {\sf GrB\_NULL}} \\
(\mathbf{D}({\sf w}))\, {\sf values[k]} & \text{ otherwise.} 
\end{cases}
\]

If multiple values for the same location are present in the input arrays and 
{\sf dup} is not {\sf GrB\_NULL}, {\sf dup} is used to reduce the values 
before assignment into $\vector{\widetilde{w}}$ as follows: 
\[
\vector{\widetilde{w}}_{i}
= \bigoplus_{k:\, {\sf indices[k]} = i}  (D_{dup})\, {\sf values[k]}
,\] 
where $\oplus$ is the {\sf dup} binary operator. Finally, the resulting 
$\vector{\widetilde{w}}$ is copied into ${\sf w}$ via typecasting its values to 
$\mathbf{D}({\sf w})$ if necessary.  If $\oplus$ is not associative or not 
commutative, the result is undefined.  

The nonopaque input arrays, {\sf indices} and {\sf values}, must be at least as
large as {\sf n}. 

It is an error to call this function on an output object with existing elements. In other words, 
{\sf GrB\_Vector\_nvals(w)} should evaluate to zero prior to calling this function.

After {\sf GrB\_Vector\_build} returns, it is safe for a programmer to 
modify or delete the arrays {\sf indices} or {\sf values}.


%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_setElement}: Set a single element in a vector}

Set one element of a vector to a given value.

\paragraph{\syntax}

\begin{verbatim}
        // scalar value
        GrB_Info GrB_Vector_setElement(GrB_Vector        w,
                                       <type>            val,
                                       GrB_Index         index);

        // GraphBLAS scalar
        GrB_Info GrB_Vector_setElement(GrB_Vector        w,
                                       const GrB_Scalar  s,
                                       GrB_Index         index);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]   ({\sf INOUT}) An existing GraphBLAS vector for which an 
    element is to be assigned.

    \item[{\sf val} or {\sf s}]   ({\sf IN}) Scalar assign.  Its domain (type) must
    be compatible with the domain of {\sf w}.

    \item[{\sf index}] ({\sf IN}) The location of the element to be assigned.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on index/dimensions and domains for the input arguments passed successfully. 
    Either way, the output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf w}, or 
    GraphBLAS scalar, {\sf s}, has not been initialized by a call to a respective constructor.
    
    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf index} specifies a location 
    that is outside the dimensions of {\sf w}.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of the vector and the scalar
    are incompatible.
\end{itemize}

\paragraph{Description}

First, the scalar and output vector are tested for domain compatibility as follows:
$\mathbf{D}({\sf val})$ or $\mathbf{D}({\sf s})$ must be compatible with $\mathbf{D}({\sf w})$. Two domains 
are compatible with each other if values from one domain can be cast to values 
in the other domain as per the rules of the C language. In particular, domains 
from Table~\ref{Tab:PredefinedTypes} are all compatible with each other. A domain 
from a user-defined type is only compatible with itself. If any compatibility 
rule above is violated, execution of {\sf GrB\_Vector\_setElement} ends and 
the domain mismatch error listed above is returned.

Then, the {\sf index} parameter is checked for a valid value where the following
condition must hold:
\[
	0\ \leq\ {\sf index}\ <\ \mathbf{size}({\sf w})
\]
If this condition is violated, execution of {\sf GrB\_Vector\_setElement} 
ends and the invalid index error listed above is returned.

We are now ready to carry out the assignment; that is: 
\begin{equation*}
    {\sf w}({\sf index}) =
    \begin{cases}
     \mathbf{L}({\sf s}),  & \text{GraphBLAS scalar.} \\
     {\sf val}, & \text{otherwise.}
    \end{cases}
\end{equation*}
In the case of a transparent scalar or if $\mathbf{L}({\sf s})$ is not empty, then a value will be stored at the specified
location in {\sf w}, overwriting any value that may have been stored there before.
In the case of a GraphBLAS scalar, if $\mathbf{L}({\sf s})$ is empty, then any
value stored at the specified location in {\sf w} will be removed.

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.


%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_removeElement}: Remove an element from a vector}

Remove (annihilate) one stored element from a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_removeElement(GrB_Vector   w,
                                          GrB_Index    index);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]   ({\sf INOUT}) An existing GraphBLAS vector from which an 
    element is to be removed.

    \item[{\sf index}] ({\sf IN}) The location of the element to be removed.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on index/dimensions and domains for the input arguments passed successfully. 
    Either way, the output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf w}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf index} specifies a location 
    that is outside the dimensions of {\sf w}.
\end{itemize}

\paragraph{Description}

First, the {\sf index} parameter is checked for a valid value where the following
condition must hold:
\[
	0\ \leq\ {\sf index}\ <\ \mathbf{size}({\sf w})
\]
If this condition is violated, execution of {\sf GrB\_Vector\_removeElement} 
ends and the invalid index error listed above is returned.

We are now ready to carry out the removal of a value that may be stored at the 
location specified by {\sf index}.  If a value does not exist at the specified 
location in {\sf w}, no error is reported and the operation has no effect on the 
state of {\sf w}.  In either case, the following will be true on return from the 
method: {\sf index} $\notin~\mathbf{ind}({\sf w})$.

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.

%-----------------------------------------------------------------------------

\subsubsection{{\sf Vector\_extractElement}: Extract a single element from a vector.}
\label{Sec:Vector_extractElement}
\label{Sec:extract_single_element_vec}

Extract one element of a vector into a scalar. 

\paragraph{\syntax}

\begin{verbatim}
        // scalar value
        GrB_Info GrB_Vector_extractElement(<type>           *val,
                                           const GrB_Vector  u,
                                           GrB_Index         index); 

        // GraphBLAS scalar
        GrB_Info GrB_Vector_extractElement(GrB_Scalar        s,
                                           const GrB_Vector  u,
                                           GrB_Index         index); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf val} or {\sf s}]   ({\sf INOUT}) An existing scalar of whose domain is 
    compatible with the domain of vector {\sf u}. On successful return, this scalar 
    holds the result of the extract. Any previous value stored in {\sf val} or {\sf s} is 
    overwritten.

    \item[{\sf u}]     ({\sf IN}) The GraphBLAS vector from which an element
    is extracted.
    
    \item[{\sf index}] ({\sf IN}) The location in {\sf u} to extract.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully. This indicates that the compatibility tests on 
    dimensions and domains for the input arguments passed successfully, and
    the output scalar, {\sf val} or {\sf s}, has been computed and is ready to be used in 
    the next method of the sequence.

    \item[{\sf GrB\_NO\_VALUE}]  When using the transparent scalar, {\sf val}, this is returned when there is no stored value at specified location.
    
    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf u}, or scalar,
    {\sf s}, has not been initialized by a call to a corresponding constructor.
    
    \item[{\sf GrB\_NULL\_POINTER}]    {\sf val} pointer is {\sf NULL}.

    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf index} specifies a location 
    that is outside the dimensions of {\sf w}.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of the vector and scalar
    are incompatible.
\end{itemize}

\paragraph{Description}

First, the scalar and input vector are tested for domain compatibility as follows:
$\mathbf{D}({\sf val})$ or $\mathbf{D}({\sf s})$ must be compatible with $\mathbf{D}({\sf u})$. Two domains 
are compatible with each other if values from one domain can be cast to values 
in the other domain as per the rules of the C language. In particular, domains 
from Table~\ref{Tab:PredefinedTypes} are all compatible with each other. A domain 
from a user-defined type is only compatible with itself. If any compatibility 
rule above is violated, execution of {\sf GrB\_Vector\_extractElement} ends and 
the domain mismatch error listed above is returned.

Then, the {\sf index} parameter is checked for a valid value where the following
condition must hold:
\[
	0\ \leq\ {\sf index}\ <\ \mathbf{size}({\sf u})
\]
If this condition is violated, execution of {\sf GrB\_Vector\_extractElement} 
ends and the invalid index error listed above is returned.

We are now ready to carry out the extract into the output scalar; that is: 
\begin{align*}
  \begin{array}{r}
    \mathbf{L}({\sf s}) \\
    {\sf val} 
  \end{array}
  \Bigg\}  =  {\sf u}({\sf index}) 
\end{align*}
If ${\sf index} \in \mathbf{ind}({\sf u})$, then the corresponding value from 
{\sf u} is copied into {\sf s} or {\sf val} with casting as necessary. If ${\sf index} \notin \mathbf{ind}({\sf u})$, then one of the follow occurs depending on output scalar type: 
\begin{itemize}
\item The GraphBLAS scalar, {\sf s}, is cleared and {\sf GrB\_SUCCESS} is returned.
\item The non-opaque scalar, {\sf val}, is unchanged, and {\sf GrB\_NO\_VALUE} is returned.
\end{itemize}

When using the non-opaque scalar variant ({\sf val}) in both {\sf GrB\_BLOCKING} mode 
{\sf GrB\_NONBLOCKING} mode, the new contents of {\sf val} are as defined above
if the method exits with return value {\sf GrB\_SUCCESS} or {\sf GrB\_NO\_VALUE}. 

When using the GraphBLAS scalar variant ({\sf s}) with a {\sf GrB\_SUCCESS} return value,
the method exits and the new contents of {\sf s} is as defined above
and fully computed in {\sf GrB\_BLOCKING} mode. In {\sf GrB\_NONBLOCKING} mode, the 
new contents of {\sf s} is as defined above but may not be fully computed; however, 
it can be used in the next GraphBLAS method call in a sequence.

%-----------------------------------------------------------------------------

\subsubsection{{\sf Vector\_extractTuples}: Extract tuples from a vector}
\label{Sec:Vector_extractTuples}

Extract the contents of a GraphBLAS vector into non-opaque data structures.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_extractTuples(GrB_Index            *indices,
                                          <type>               *values,
                                          GrB_Index            *n, 
                                          const GrB_Vector      v);

\end{verbatim}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf indices}] ({\sf OUT}) Pointer to an array of indices that is
                        large enough to hold all of the stored values' indices.
    \item[{\sf values}] ({\sf OUT}) Pointer to an array of scalars of a type 
                        that is large enough to hold all of the stored values
                        whose type is compatible with $\mathbf{D}(\vector{v})$.
    \item[{\sf n}] ({\sf INOUT}) Pointer to a value indicating (on input) the number of
                        elements the {\sf values} and
                        {\sf indices} arrays can hold. Upon return, it will contain the
                        number of values written to the arrays.
    \item[{\sf v}]      ({\sf IN})  An existing GraphBLAS vector.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully. This indicates that the compatibility tests on 
    the input argument passed successfully, and the output arrays, {\sf indices}
    and {\sf values}, have been computed.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.

    \item[{\sf GrB\_INSUFFICIENT\_SPACE}]  Not enough space in {\sf indices} and 
    {\sf values} (as indicated by the {\sf n} parameter) to hold all of the 
    tuples that will be extacted.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf v}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}] {\sf indices}, {\sf values}, or {\sf n}
    pointer is {\sf NULL}.
     
    \item[{\sf GrB\_DOMAIN\_MISMATCH}] The domains of the {\sf v} vector or 
    {\sf values} array are incompatible with one another.
\end{itemize}


\paragraph{Description}


This method will extract all the tuples from the GraphBLAS vector {\sf v}.  
The values associated with those tuples are placed in the
{\sf values} array and the indices are placed in the {\sf indices} array. 
Both {\sf indices} and {\sf values} must be pre-allocated by the user to have enough
space to hold at least {\sf GrB\_Vector\_nvals(v)} elements before calling
this function. 

Upon return of this function, {\sf n} will be set to the number of values (and 
indices) copied.  Also, the entries of {\sf indices} are unique, but not 
necessarily sorted.  Each tuple $(i,v_i)$ in {\sf v} is unzipped and copied 
into a distinct $k$th location in output vectors:

$$ \{{\sf indices[k]}, {\sf values[k]}\} \leftarrow (i,v_i),$$

where $0 \leq k < {\sf GrB\_Vector\_nvals(v)}$. No gaps in
output vectors are allowed; that is, if {\sf indices[k]} and {\sf values[k]} 
exist upon return, so does
{\sf indices[j]} and {\sf values[j]} for all $j$ such that $0 \leq j < k$.

Note that if the value in {\sf n} on input is less than the number of values
contained in the vector {\sf v}, then a {\sf GrB\_INSUFFICIENT\_SPACE} error 
is returned because it is undefined which subset of values would
be extracted otherwise.

In both {\sf GrB\_BLOCKING} mode {\sf GrB\_NONBLOCKING} mode
if the method exits with return value {\sf GrB\_SUCCESS}, the  new 
contents of the arrays {\sf indices} and {\sf values} are as defined above.  


%==============================================================================
\subsection{Matrix methods}

%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_new}: Construct new matrix}

Creates a new matrix with specified domain and dimensions.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_new(GrB_Matrix *A,
                                GrB_Type    d,
                                GrB_Index   nrows,
                                GrB_Index   ncols);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf A}] ({\sf INOUT}) On successful return, contains a handle to 
                                 the newly created GraphBLAS matrix.
    \item[{\sf d}] ({\sf IN})    The type corresponding to the domain of the matrix 
                                 being created. Can be one of the predefined
                                 GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, 
                                 or an existing user-defined GraphBLAS type.
    \item[{\sf nrows}] ({\sf IN}) The number of rows of the matrix being created.
    \item[{\sf ncols}] ({\sf IN}) The number of columns of the matrix being created.
\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf A} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The {\sf GrB\_Type} object has not 
    been initialized by a call to {\sf GrB\_Type\_new} (needed for user-defined types).
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf A} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_INVALID\_VALUE}] {\sf nrows} or {\sf ncols} is zero or outside the range of the type {\sf GrB\_Index}.
\end{itemize}

\paragraph{Description}

Creates a new matrix $\matrix{A}$ of domain $\mathbf{D}({\sf d})$, size 
{\sf nrows $\times$ ncols}, and empty $\mathbf{L}(\matrix{A})$. The method returns a
handle to the new matrix in {\sf A}.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created object will be overwritten. 

%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_dup}: Construct a copy of a GraphBLAS matrix}

Creates a new matrix with the same domain, dimensions, and contents as 
another matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_dup(GrB_Matrix       *C,
                                const GrB_Matrix  A);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}] ({\sf INOUT}) On successful return, contains a handle to 
                                 the newly created GraphBLAS matrix.
    \item[{\sf A}] ({\sf IN})    The GraphBLAS matrix to be duplicated.
\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf C} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to any matrix constructor.
    
    \item[{\sf GrB\_NULL\_POINTER}]   The {\sf C} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Creates a new matrix $\matrix{C}$ of domain $\mathbf{D}({\sf A})$, size 
$\mathbf{nrows}({\sf A}) \times \mathbf{ncols}({\sf A})$, and contents 
$\mathbf{L}({\sf A})$. It returns a handle to it in {\sf C}.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created object will be overwritten. 

%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_diag}: Construct a diagonal GraphBLAS matrix}

Creates a new matrix with the same domain and contents as a {\sf GrB\_Vector}, 
and square dimensions appropriate for placing the contents of the vector along the 
specified diagonal of the matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_diag(GrB_Matrix       *C,
                                 const GrB_Vector  v,
                                 int64_t           k);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}] ({\sf INOUT}) On successful return, contains a handle to 
                                 the newly created GraphBLAS matrix.  The 
                                 matrix is square with each dimension equal to
                                 $\mathbf{size}({\sf v}) + |k|$.
    \item[{\sf v}] ({\sf IN})    The GraphBLAS vector whose contents will be
                                 copied to the diagonal of the matrix.
    \item[{\sf k}] ({\sf IN})    The diagonal to which the vector is assigned. {\sf k} = 0
                                 represents the main diagonal, {\sf k} > 0 is above the main 
                                 diagonal, and {\sf k} < 0 is below.
\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf C} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for the operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf v}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]   The {\sf C} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Creates a new matrix $\matrix{C}$ of domain $\mathbf{D}({\sf v})$, size 
$(\mathbf{size}({\sf v}) + |k|) \times (\mathbf{size}({\sf v}) + |k|)$, and contents 
\begin{eqnarray*}
\mathbf{L}({\sf C}) & = & \{ (i, i + k, v_i) ~:~ (i, v_i) \in \mathbf{L}({\sf v})\} \mbox{~if~} k \ge 0
\mbox{~or} \\
\mathbf{L}({\sf C}) & = & \{ (i - k, i, v_i) ~:~ (i, v_i) \in \mathbf{L}({\sf v})\} \mbox{~if~} k < 0.
\end{eqnarray*}
It returns a handle to it in {\sf C}.  It is not an error to call this method 
more than once on the same variable; however, the handle to the previously 
created object will be overwritten. 

%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_resize}: Resize a matrix}

Changes the dimensions of an existing matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_resize(GrB_Matrix  C,
                                   GrB_Index   nrows,
                                   GrB_Index   ncols);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}] ({\sf INOUT}) An existing Matrix object that is being resized.
    \item[{\sf nrows}] ({\sf IN}) The new number of rows of the matrix. It can be smaller or larger than the current number of rows.
    \item[{\sf ncols}] ({\sf IN}) The new number of columns of the matrix. It can be smaller or larger than the current number of columns.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf C} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf C} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_INVALID\_VALUE}] {\sf nrows} or {\sf ncols} is zero or outside the range of the type {\sf GrB\_Index}.
\end{itemize}

\paragraph{Description}

Changes the number of rows and columsn of ${\sf C}$ to {\sf nrows} and {\sf ncols}, respectively. The domain
$\mathbf{D}({\sf C})$ of matrix ${\sf C}$ remains the same. The
contents $\mathbf{L}({\sf C})$ are modified as described below.

Let ${\sf C} = \langle \mathbf{D}({\sf C}), M, N, \mathbf{L}({\sf C})
\rangle$ when the method is called. When the method returns {\sf C} is modified to ${\sf C}
= \langle \mathbf{D}({\sf C}), {\sf nrows}, {\sf ncols}, \mathbf{L'}({\sf C})
\rangle$ where $\mathbf{L'}({\sf C}) = \{(i,j,C_{ij}) : (i,j,C_{ij}) \in
\mathbf{L}({\sf C}) \wedge (i < {\sf nrows}) \wedge (j < {\sf ncols})\}$. That is, all elements
of ${\sf C}$ with row index greater than or equal to 
${\sf nrows}$ or column index greater than or equal to ${\sf ncols}$ are dropped.

%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_clear}: Clear a matrix}

Removes all elements (tuples) from a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_clear(GrB_Matrix A);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf A}] ({\sf IN}) An exising GraphBLAS matrix to clear.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf A} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to any matrix constructor.
    
\end{itemize}

\paragraph{Description}

Removes all elements (tuples) from an existing matrix. After the call to
{\sf GrB\_Matrix\_clear(A)},
$\mathbf{L}(\matrix{A}) = \emptyset$. The dimensions of the matrix do not change.


%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_nrows}: Number of rows in a matrix}

Retrieve the number of rows in a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_nrows(GrB_Index        *nrows,
                                  const GrB_Matrix  A);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf nrows}] ({\sf OUT}) On successful return, contains the number of rows in the matrix.
    \item[{\sf A}] ({\sf IN}) An existing GraphBLAS matrix being queried.
\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]   In blocking or non-blocking mode, the operation 
    completed successfully and the value of {\sf nrows} has been set.

    \item[{\sf GrB\_PANIC}]     Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to any matrix constructor.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf nrows} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Return $\mathbf{nrows}({\sf A})$ in {\sf nrows} (the number of rows).

%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_ncols}: Number of columns in a matrix}

Retrieve the number of columns in a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_ncols(GrB_Index        *ncols,
                                  const GrB_Matrix  A);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf ncols}] ({\sf OUT}) On successful return, contains the number of columns in the matrix.
    \item[{\sf A}] ({\sf IN}) An existing GraphBLAS matrix being queried.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]   In blocking or non-blocking mode, the operation 
    completed successfully and the value of {\sf ncols} has been set.

    \item[{\sf GrB\_PANIC}]     Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to any matrix constructor.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf ncols} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Return $\mathbf{ncols}({\sf A})$ in {\sf ncols} (the number of columns).

%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_nvals}: Number of stored elements in a matrix}
\label{Sec:Matrix_nvals}

Retrieve the number of stored elements (tuples) in a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_nvals(GrB_Index        *nvals,
                                  const GrB_Matrix  A);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf nvals}] ({\sf OUT}) On successful return, contains the number of 
    stored elements (tuples) in the matrix.
    \item[{\sf A}] ({\sf IN}) An existing GraphBLAS matrix being queried.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully and the value of {\sf nvals} has been set. 

    \item[{\sf GrB\_PANIC}]    Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to any matrix constructor.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf nvals} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Return $\mathbf{nvals}({\sf A})$ in {\sf nvals}.  This is the number of tuples 
stored in matrix {\sf A}, which is the size of $\mathbf{L}(\matrix{A})$
(see Section~\ref{Sec:Matrices}).

%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_build}: Store elements from tuples into a matrix}
\label{Sec:Matrix_build}

\paragraph{\syntax}

% AYDIN: Avoid page break due to preceding table
\begin{Verbatim}[samepage=true]    
        GrB_Info GrB_Matrix_build(GrB_Matrix             C,
                                  const GrB_Index       *row_indices,
                                  const GrB_Index       *col_indices, 
                                  const <type>          *values,
                                  GrB_Index              n,
                                  const GrB_BinaryOp     dup);
\end{Verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]      ({\sf INOUT}) An existing Matrix object to store the result.
    \item[{\sf row\_indices}] ({\sf IN}) Pointer to an array of row indices. 
    \item[{\sf col\_indices}] ({\sf IN}) Pointer to an array of column indices. 
    \item[{\sf values}] ({\sf IN}) Pointer to an array of scalars of a type that
                                   is compatible with the domain of matrix, {\sf C}.
    \item[{\sf n}]  ({\sf IN}) The number of entries contained in each array (the same for \arg{row\_indices}, \arg{col\_indices}, and \arg{values}).
    \item[{\sf dup}]    ({\sf IN}) An associative and commutative binary operator 
    to apply when duplicate values for the same location are present in the input
    arrays. All three domains of {\sf dup} must be the same; hence
	    $dup=\langle D_{dup},D_{dup},D_{dup},\oplus \rangle$.
    If {\sf dup} is {\sf GrB\_NULL}, then duplicate locations will result in an error.
\end{itemize}    

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf C} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  Either {\sf C} has not been 
    initialized by a call to any matrix constructor, or
    {\sf dup} has not been initialized by a call to {\sf by GrB\_BinaryOp\_new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf row\_indices}, 
    {\sf col\_indices} or {\sf values} pointer is {\sf NULL}.

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}] A value in {\sf row\_indices} or
    {\sf col\_indices} is outside the allowed range for {\sf C}.

	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Either the domains of the GraphBLAS 
    binary operator {\sf dup} are not all the same, or the domains of 
    {\sf values} and {\sf C} are incompatible with each other or $D_{dup}$.
	
	\item[{\sf GrB\_OUTPUT\_NOT\_EMPTY}]    Output matrix {\sf C} already contains valid tuples (elements).
	In other words, {\sf GrB\_Matrix\_nvals(C)} returns a positive value.
    
    \item[{\sf GrB\_INVALID\_VALUE}] {\sf indices} contains a duplicate location
    and {\sf dup} is {\sf GrB\_NULL}.
\end{itemize}

\paragraph{Description}

If {\sf dup} is not {\sf GrB\_NULL}, an internal matrix 
$\matrix{\widetilde{C}} = \langle D_{dup}, \mathbf{nrows}({\sf C}),
\mathbf{ncols}({\sf C}),\emptyset \rangle$ is created, which only differs from ${\sf C}$ 
in its domain; otherwise,
$\matrix{\widetilde{C}} = \langle \mathbf{D}({\sf C}), \mathbf{nrows}({\sf C}),
\mathbf{ncols}({\sf C}),\emptyset \rangle$. 

Each tuple $\{ {\sf row\_indices[k]}, {\sf col\_indices[k]}, {\sf values[k]}\}$, where $0\leq k < {\sf n}$, is a contribution to the output in the form of 
\[
\matrix{\widetilde{C}}({\sf row\_indices[k]}, {\sf col\_indices[k]}) = 
\begin{cases} 
(D_{dup})\, {\sf values[k]} & \text{ if {\sf dup} $\neq$ {\sf GrB\_NULL}} \\
(\mathbf{D}({\sf C}))\, {\sf values[k]} & \text{ otherwise.} 
\end{cases}
\]

If multiple values for the same location are present in the input arrays and 
{\sf dup} is not {\sf GrB\_NULL}, {\sf dup} is used to reduce the values before 
assignment into $\matrix{\widetilde{C}}$ as follows:
\[
\matrix{\widetilde{C}}_{ij}
= \bigoplus_{k:\, {\sf row\_indices[k]} = i\, \land\, {\sf col\_indices[k]} = j}   (D_{dup})\,{\sf values[k]}
,\] 
where $\oplus$ is the {\sf dup} binary operator. Finally, the resulting 
$\matrix{\widetilde{C}}$ is copied into ${\sf C}$ via typecasting its values to 
$\mathbf{D}({\sf C})$ if necessary.  If $\oplus$ is not associative or not 
commutative, the result is undefined.  

The nonopaque input arrays {\sf row\_indices}, {\sf col\_indices}, and {\sf values} must be at least as large as {\sf n}. 

It is an error to call this function on an output object with existing elements. In other words, 
{\sf GrB\_Matrix\_nvals(C)} should evaluate to zero prior to calling this function.

After {\sf GrB\_Matrix\_build} returns, it is safe for a programmer to 
modify or delete the arrays {\sf row\_indices}, {\sf col\_indices}, or {\sf values}.

%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_setElement}: Set a single element in matrix}

Set one element of a matrix to a given value.

\paragraph{\syntax}

\begin{verbatim}
        // scalar value
        GrB_Info GrB_Matrix_setElement(GrB_Matrix         C,
                                       <type>             val,
                                       GrB_Index          row_index,
                                       GrB_Index          col_index); 

        // GraphBLAS scalar
        GrB_Info GrB_Matrix_setElement(GrB_Matrix         C,
                                       const GrB_Scalar   s,
                                       GrB_Index          row_index,
                                       GrB_Index          col_index); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]   ({\sf INOUT}) An existing GraphBLAS matrix for which an 
    element is to be assigned.

    \item[{\sf val} or {\sf s}]   ({\sf IN})  Scalar to assign.  Its domain (type) must
    be compatible with the domain of {\sf C}.
    
    \item[{\sf row\_index}] ({\sf IN}) Row index of element to be assigned
    \item[{\sf col\_index}] ({\sf IN}) Column index of element to be assigned
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on index/dimensions and domains for the input arguments passed successfully. 
    Either way, the output matrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, or 
    GraphBLAS scalar, {\sf s}, has not been initialized by a call to a respective constructor.

    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf row\_index} or {\sf col\_index} is 
    outside the allowable range (i.e., not less than $\mathbf{nrows}({\sf C})$ or
    $\mathbf{ncols}({\sf C})$, respectively).

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]  The domains of the matrix and the scalar
    are incompatible.
\end{itemize}

\paragraph{Description}

First, the scalar and output matrix are tested for domain compatibility as follows:  
$\mathbf{D}({\sf val})$ or $\mathbf{D}({\sf s})$ must be compatible with $\mathbf{D}({\sf C})$. Two domains 
are compatible with each other if values from one domain can be cast to values 
in the other domain as per the rules of the C language.  In particular, domains 
from Table~\ref{Tab:PredefinedTypes} are all compatible with each other. A domain 
from a user-defined type is only compatible with itself.  If any compatibility 
rule above is violated, execution of {\sf GrB\_Matrix\_setElement} ends and
the domain mismatch error listed above is returned.

Then, both index parameters are checked for valid values where following
conditions must hold:
\[
\begin{aligned}
    0\ \leq\ {\sf row\_index} & \ <\ \mathbf{nrows}({\sf C}), \\
    0\ \leq\ {\sf col\_index} & \ <\ \mathbf{ncols}({\sf C})
\end{aligned}
\]
If either of these conditions is violated, execution of 
{\sf GrB\_Matrix\_setElement} ends and the invalid 
index error listed above is returned. 

We are now ready to carry out the assignment; that is: 
\begin{equation*}
    {\sf C}({\sf row\_index},{\sf col\_index}) =
    \begin{cases}
     \mathbf{L}({\sf s}),  & \text{GraphBLAS scalar.} \\
     {\sf val}, & \text{otherwise.}
    \end{cases}
\end{equation*}
In the case of a transparent scalar or if $\mathbf{L}({\sf s})$ is not empty, then a value will be stored at the specified
location in {\sf C}, overwriting any value that may have been stored there before.
In the case of a GraphBLAS scalar and if $\mathbf{L}({\sf s})$ is empty, then any
value stored at the specified location in {\sf C} will be removed.

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of {\sf C} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf C} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.


%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_removeElement}: Remove an element from a matrix}

Remove (annihilate) one stored element from a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_removeElement(GrB_Matrix   C,
                                          GrB_Index    row_index,
                                          GrB_Index    col_index); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]   ({\sf INOUT}) An existing GraphBLAS matrix from which an 
    element is to be removed.

    \item[{\sf row\_index}] ({\sf IN}) Row index of element to be removed
    \item[{\sf col\_index}] ({\sf IN}) Column index of element to be removed
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on index/dimensions and domains for the input arguments passed successfully. 
    Either way, the output matrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf C}, has 
    not been initialized by a call to any matrix constructor.

    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf row\_index} or {\sf col\_index} is 
    outside the allowable range (i.e., not less than $\mathbf{nrows}({\sf C})$ or
    $\mathbf{ncols}({\sf C})$, respectively).
\end{itemize}

\paragraph{Description}

First, both index parameters are checked for valid values where following
conditions must hold:
\[
\begin{aligned}
    0\ \leq\ {\sf row\_index} & \ <\ \mathbf{nrows}({\sf C}), \\
    0\ \leq\ {\sf col\_index} & \ <\ \mathbf{ncols}({\sf C})
\end{aligned}
\]
If either of these conditions is violated, execution of 
{\sf GrB\_Matrix\_removeElement} ends and the invalid 
index error listed above is returned. 

We are now ready to carry out the removal of a value that may be stored at the
location specified by ({\sf row\_index}, {\sf col\_index}).  If a value does not
exist at the specified location in {\sf C}, no error is reported and the 
operation has no effect on the state of {\sf C}.  In either case, the following 
will be true on return from this method: 
({\sf row\_index}, {\sf col\_index}) $\notin~\mathbf{ind}({\sf C})$

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of {\sf C} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf C} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.


%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_extractElement}: Extract a single element from a matrix}
\label{Sec:Matrix_extractElement}
\label{Sec:extract_single_element_mat}

Extract one element of a matrix into a scalar. 

\paragraph{\syntax}

\begin{verbatim}
        // scalar value
        GrB_Info GrB_Matrix_extractElement(<type>           *val,
                                           const GrB_Matrix  A,
                                           GrB_Index         row_index,
                                           GrB_Index         col_index);

        // GraphBLAS scalar
        GrB_Info GrB_Matrix_extractElement(GrB_Scalar        s,
                                           const GrB_Matrix  A,
                                           GrB_Index         row_index,
                                           GrB_Index         col_index); 

\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf val} or {\sf s}]   ({\sf INOUT}) An existing scalar whose domain is 
    compatible with the domain of matrix {\sf A}. On successful return, this scalar 
    holds the result of the extract.  Any previous value stored in {\sf val} or {\sf s} is 
    overwritten.

    \item[{\sf A}]     ({\sf IN}) The GraphBLAS matrix from which an element is
    extracted.
    
    \item[{\sf row\_index}] ({\sf IN}) The row index of location in {\sf A} 
    to extract.

    \item[{\sf col\_index}] ({\sf IN}) The column index of location in {\sf A} 
    to extract.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully. This indicates that the compatibility tests on 
    dimensions and domains for the input arguments passed successfully, and
    the output scalar, {\sf val} or {\sf s}, has been computed and is ready to be used in 
    the next method of the sequence.

    \item[{\sf GrB\_NO\_VALUE}]  When using the transparent scalar, {\sf val}, this is returned when there is no stored value at specified location.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, or scalar,
    {\sf s}, has not been initialized by a call to a corresponding constructor.

    \item[{\sf GrB\_NULL\_POINTER}]    {\sf val} pointer is {\sf NULL}.

    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf row\_index} or {\sf col\_index} is 
    outside the allowable range (i.e. less than zero or greater than or equal to 
    $\mathbf{nrows}({\sf A})$ or $\mathbf{ncols}({\sf A})$, respectively).

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of the matrix and scalar
    are incompatible.
\end{itemize}

\paragraph{Description}

First, the scalar and input matrix are tested for domain compatibility as follows:  
$\mathbf{D}({\sf val})$ or $\mathbf{D}({\sf s})$ must be compatible with $\mathbf{D}({\sf A})$. Two domains 
are compatible with each other if values from one domain can be cast to values 
in the other domain as per the rules of the C language.  In particular, domains 
from Table~\ref{Tab:PredefinedTypes} are all compatible with each other. A domain 
from a user-defined type is only compatible with itself.  If any compatibility 
rule above is violated, execution of {\sf GrB\_Matrix\_extractElement} ends and
the domain mismatch error listed above is returned.

Then, both index parameters are checked for valid values where following
conditions must hold:
\[
\begin{aligned}
    0\ \leq\ {\sf row\_index} & \ <\ \mathbf{nrows}({\sf A}), \\
    0\ \leq\ {\sf col\_index} & \ <\ \mathbf{ncols}({\sf A})
\end{aligned}
\]
If either condition is violated, execution of 
{\sf GrB\_Matrix\_extractElement} ends and the invalid 
index error listed above is returned. 

We are now ready to carry out the extract into the output scalar; that is,
\begin{align*}
  \begin{array}{r}
    \mathbf{L}({\sf s}) \\
    {\sf val} 
  \end{array}
  \Bigg\}  =  {\sf A}({\sf row\_index},{\sf col\_index})
\end{align*}
If $({\sf row\_index},{\sf col\_index}) \ \in \ \mathbf{ind}({\sf A})$, then the corresponding value from 
{\sf A} is copied into {\sf s} or {\sf val} with casting as necessary. If $({\sf row\_index},{\sf col\_index}) \ \notin \ \mathbf{ind}({\sf A})$, then one of the follow occurs depending on output scalar type: 
\begin{itemize}
\item The GraphBLAS scalar, {\sf s}, is cleared and {\sf GrB\_SUCCESS} is returned.
\item The non-opaque scalar, {\sf val}, is unchanged, and {\sf GrB\_NO\_VALUE} is returned.
\end{itemize}

When using the non-opaque scalar variant ({\sf val}) in both {\sf GrB\_BLOCKING} mode 
{\sf GrB\_NONBLOCKING} mode, the new contents of {\sf val} are as defined above
if the method exits with return value {\sf GrB\_SUCCESS} or {\sf GrB\_NO\_VALUE}. 

When using the GraphBLAS scalar variant ({\sf s}) with a {\sf GrB\_SUCCESS} return value,
the method exits and the new contents of {\sf s} is as defined above
and fully computed in {\sf GrB\_BLOCKING} mode. In {\sf GrB\_NONBLOCKING} mode, the 
new contents of {\sf s} is as defined above but may not be fully computed; however, 
it can be used in the next GraphBLAS method call in a sequence.


%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_extractTuples}: Extract tuples from a matrix}
\label{Sec:Matrix_extractTuples}

Extract the contents of a GraphBLAS matrix into non-opaque data structures.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_extractTuples(GrB_Index            *row_indices,
                                          GrB_Index            *col_indices,
                                          <type>               *values, 
                                          GrB_Index            *n, 
                                          const GrB_Matrix      A);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf row\_indices}] ({\sf OUT}) Pointer to an array of row indices
                        that is large enough to hold all of the row indices.
    \item[{\sf col\_indices}] ({\sf OUT}) Pointer to an array of column indices
                        that is large enough to hold all of the column indices. 
    \item[{\sf values}] ({\sf OUT}) Pointer to an array of scalars of a type
                        that is large enough to hold all of the stored values whose
                        type is compatible with $\mathbf{D}(\matrix{A})$.
    \item[{\sf n}] ({\sf INOUT}) Pointer to a value indicating (in input) the number of
                        elements the {\sf values}, {\sf row\_indices}, and
                        {\sf col\_indices} arrays can hold. Upon return, it will contain the
                        number of values written to the arrays.
    \item[{\sf A}]      ({\sf IN}) An existing GraphBLAS matrix.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully. This indicates that the compatibility tests on 
    the input argument passed successfully, and the output arrays, {\sf indices}
    and {\sf values}, have been computed.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.

    \item[{\sf GrB\_INSUFFICIENT\_SPACE}]  Not enough space in {\sf row\_indices}, 
    {\sf col\_indices}, and {\sf values} (as indicated by the {\sf n} parameter) 
    to hold all of the tuples that will be extacted.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to any matrix constructor.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf row\_indices}, {\sf col\_indices}, 
    {\sf values} or {\sf n} pointer is {\sf NULL}.
    
    \item[\sf GrB\_DOMAIN\_MISMATCH] The domains of the {\sf A} matrix and 
    {\sf values} array are incompatible with one another.
\end{itemize}

\paragraph{Description}


This method will extract all the tuples from the GraphBLAS matrix {\sf A}.  
The values associated with those tuples are placed in the
{\sf values} array, the column indices are placed in the {\sf col\_indices} array, 
and the row indices are placed in the {\sf row\_indices} array. 
These output arrays are pre-allocated by the user before calling
this function such that each output array has enough
space to hold at least {\sf GrB\_Matrix\_nvals(A)} elements. 

Upon return of this function, a pair of $\{{\sf row\_indices[k], col\_indices[k]}\}$ are unique for every valid $k$, 
but they are not required to be sorted in any particular order.
Each tuple $(i,j,A_{ij})$ in {\sf A} is unzipped and copied into a distinct $k$th location in output vectors:  

$$\{{\sf row\_indices[k]}, {\sf col\_indices[k]}, {\sf values[k]}\} \leftarrow (i,j,A_{ij}),$$

where $0 \leq k < {\sf GrB\_Matrix\_nvals(v)}$. 
No gaps in output vectors are allowed; that is, if {\sf row\_indices[k]},  {\sf col\_indices[k]}  and {\sf values[k]} exist upon return, 
so does {\sf row\_indices[j]}, {\sf col\_indices[j]} and {\sf values[j]} for all $j$ such that $0 \leq j < k$.

Note that if the value in {\sf n} on input is less than the number of values
contained in the matrix {\sf A}, then a {\sf GrB\_INSUFFICIENT\_SPACE} error 
is returned since it is undefined which subset of values would
be extracted.

In both {\sf GrB\_BLOCKING} mode {\sf GrB\_NONBLOCKING} mode
if the method exits with return value {\sf GrB\_SUCCESS}, the  new 
contents of the arrays {\sf row\_indices}, {\sf col\_indices} and {\sf values} are as defined above.  


%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_exportHint}: Provide a hint as to which storage format might be most efficient for exporting a matrix}
\label{Sec:Matrix_exportHint}

\paragraph{\syntax}

\begin{Verbatim}[samepage=true]    
        GrB_Info GrB_Matrix_exportHint(GrB_Format            *hint,
                                       GrB_Matrix             A);
\end{Verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf hint}] ({\sf OUT}) Pointer to a value of type \arg{GrB\_Format}.
    \item[{\sf A}]    ({\sf IN}) A GraphBLAS matrix object.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]   In blocking or non-blocking mode, the operation 
    completed successfully and the value of \arg{hint} has been set.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to any matrix constructor.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf hint} is {\sf NULL}.

    \item[{\sf GrB\_NO\_VALUE}]  If the implementation does not have a preferred
    format, it may return the value {\sf GrB\_NO\_VALUE}.
\end{itemize}

\paragraph{Description}

Given a GraphBLAS matrix \arg{A}, provide a hint as to which format might be most
efficient for exporting the matrix \arg{A}.  GraphBLAS implementations might
return the current storage format of the matrix, or the format to which it could
most efficiently be exported.  However, implementations are free to return any
value for \arg{format} defined in Section~\ref{Sec:GrB_Format}.  Note that an
implementation is free to refuse to provide a format hint, returning
{\sf GrB\_NO\_VALUE}.

%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_exportSize}: Return the array sizes necessary to export a GraphBLAS matrix object}
\label{Sec:Matrix_exportSize}

\paragraph{\syntax}

\begin{Verbatim}[samepage=true]    
        GrB_Info GrB_Matrix_exportSize(GrB_Index             *n_indptr,
                                       GrB_Index             *n_indices,
                                       GrB_Index             *n_values,
                                       GrB_Format             format,
                                       GrB_Matrix             A);
\end{Verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf n\_indptr}]  ({\sf OUT}) Pointer to a value of type \arg{GrB\_Index}.
    \item[{\sf n\_indices}] ({\sf OUT}) Pointer to a value of type \arg{GrB\_Index}.
    \item[{\sf n\_values}]  ({\sf OUT}) Pointer to a value of type \arg{GrB\_Index}.
    \item[{\sf format}] ({\sf IN}) a value indicating the format in which the matrix
    will be exported, as defined in Section~\ref{Sec:GrB_Format}.
    \item[{\sf A}]      ({\sf IN}) A GraphBLAS matrix object.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]   In blocking mode or non-blocking mode, the
    operation completed successfully. This indicates that the API checks 
    for the input arguments passed successfully, and the number of elements necessary
    for the export buffers have been written to {\sf n\_indptr}, {\sf n\_indices},
    and {\sf n\_values}, respectively.

    \item[{\sf GrB\_PANIC}]     Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS Matrix, {\sf A}, has 
    not been initialized by a call to any matrix constructor.

    \item[{\sf GrB\_NULL\_POINTER}]  {\sf n\_indptr}, 
    {\sf n\_indices}, or {\sf n\_values} is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Given a matrix $\matrix{A}$, returns the required capacities of arrays \arg{values},
\arg{indptr}, and \arg{indices} necessary to export the matrix in the format specified by \arg{format}.
The output values \arg{n\_values}, \arg{n\_indptr}, and \arg{indices} will
contain the corresponding sizes of the arrays (in number of elements) that must be allocated to hold
the exported matrix.  The argument \arg{format} can be chosen arbitrarily by the
user as one of the values defined in Section~\ref{Sec:GrB_Format}.

%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_export}: Export a GraphBLAS matrix to a pre-defined format}
\label{Sec:Matrix_export}

\paragraph{\syntax}

\begin{Verbatim}[samepage=true]    
        GrB_Info GrB_Matrix_export(GrB_Index             *indptr,
                                   GrB_Index             *indices,
                                   <type>                *values,
                                   GrB_Index             *n_indptr, 
                                   GrB_Index             *n_indices, 
                                   GrB_Index             *n_values, 
                                   GrB_Format             format,
                                   GrB_Matrix             A);
\end{Verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf indptr}] ({\sf INOUT}) Pointer to an array that will hold row or 
                        column offsets, or row indices, depending on the value 
                        of \arg{format}. It must be large enough to hold at least 
                        \arg{n\_indptr} elements of type \arg{GrB\_Index}, where 
                        \arg{n\_indices} was returned from 
                        \arg{GrB\_Matrix\_exportSize()} method.

    \item[{\sf indices}] ({\sf INOUT}) Pointer to an array that will hold row or 
                        column indices of the elements in \arg{values}, depending 
                        on the value of \arg{format}.  It must be large enough to 
                        hold at least \arg{n\_indices} elements of type 
                        \arg{GrB\_Index}, where \arg{n\_indices} was returned 
                        from \arg{GrB\_Matrix\_exportSize()} method.

    \item[{\sf values}] ({\sf INOUT}) Pointer to an array that will hold stored values.  
                        The type of element must match the type of the values stored 
                        in \arg{A}. It must be large enough to hold at least 
                        \arg{n\_values} elements of that type, where \arg{n\_values} 
                        was returned from \arg{GrB\_Matrix\_exportSize}.

    \item[{\sf n\_indptr}] ({\sf INOUT}) Pointer to a value indicating (on input)
                        the number of elements the {\sf indptr} array can hold.
                        Upon return, it will contain the number of elements written
                        to the array.

    \item[{\sf n\_indices}] ({\sf INOUT}) Pointer to a value indicating (on input)
                        the number of elements the {\sf indices} array can hold. 
                        Upon return, it will contain the number of elements written 
                        to the array.

    \item[{\sf n\_values}] ({\sf INOUT}) Pointer to a value indicating (on input)
                        the number of elements the {\sf values} array can hold. 
                        Upon return, it will contain the number of elements written
                        to the array.

    \item[{\sf format}] ({\sf IN}) a value indicating the format in which the matrix
                        will be exported, as defined in Section~\ref{Sec:GrB_Format}.

    \item[{\sf A}]      ({\sf IN}) A GraphBLAS matrix object.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking or non-blocking mode, the
    operation completed successfully. This indicates that the compatibility tests on 
    the input argument passed successfully, and the output arrays, \arg{indptr}, 
    \arg{indices} and \arg{values}, have been computed.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.

    \item[{\sf GrB\_INSUFFICIENT\_SPACE}]  Not enough space in {\sf indptr}, 
    {\sf indices}, and/or {\sf values} (as indicated by the corresponding 
    {\sf n\_*} parameter) to hold all of the corresponding elements that will be extacted.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to any matrix constructor.

    \item[{\sf GrB\_NULL\_POINTER}]  {\sf indptr}, {\sf indices}, {\sf values} 
    {\sf n\_indptr}, {\sf n\_indices}, {\sf n\_values} pointer is {\sf NULL}.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domain of {\sf A} does not match
    with the type of {\sf values}.
\end{itemize}

\paragraph{Description}

Given a matrix $\matrix{A}$, this method exports the contents of the matrix into 
one of the pre-defined \arg{GrB\_Format} formats from Section~\ref{Sec:GrB_Format}.
The user-allocated arrays pointed to by \arg{indptr}, \arg{indices}, and \arg{values} must be at least
large enough to hold the corresponding number of elements returned by calling
\arg{GrB\_Matrix\_exportSize}.  The value of \arg{format} can be chosen arbitrarily,
but a call to \arg{GrB\_Matrix\_exportHint} may suggest a format that results in the
most efficient export.  Details of the contents of \arg{indptr}, \arg{indices}, 
and \arg{values} corresponding to each supported format is given in 
Appendix~\ref{App:Matrix_format_details}.

%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_import}: Import a matrix into a GraphBLAS object}
\label{Sec:Matrix_import}

\paragraph{\syntax}

\begin{Verbatim}[samepage=true]    
        GrB_Info GrB_Matrix_import(GrB_Matrix            *A,
                                   GrB_Type               d,
                                   GrB_Index              nrows,
                                   GrB_Index              ncols
                                   const GrB_Index       *indptr,
                                   const GrB_Index       *indices,
                                   const <type>          *values,
                                   GrB_Index              n_indptr,
                                   GrB_Index              n_indices,
                                   GrB_Index              n_values,
                                   GrB_Format             format);
\end{Verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf A}] ({\sf INOUT})   On a successful return, contains a handle 
                   to the newly created GraphBLAS matrix.
    \item[{\sf d}] ({\sf IN})    The type corresponding to the domain of the 
                   matrix being created. Can be one of the predefined GraphBLAS
                   types in Table~\ref{Tab:PredefinedTypes},  or an existing
                   user-defined GraphBLAS type.
    \item[{\sf nrows}] ({\sf IN}) Integer value holding the number of rows in the matrix.
    \item[{\sf ncols}] ({\sf IN}) Integer value holding the number of columns in the matrix.
    \item[{\sf indptr}] ({\sf IN}) Pointer to an array of row or column offsets, 
                   or row indices, depending on the value of \arg{format}.
    \item[{\sf indices}] ({\sf IN}) Pointer to an array row or column indices 
                   of the elements in \arg{values}, depending on the value of \arg{format}.
    \item[{\sf values}] ({\sf IN}) Pointer to an array of values.  Type must match the type of \arg{d}.
    \item[{\sf n\_indptr}] ({\sf IN}) Integer value holding the number of 
                   elements in the array pointed to by \arg{indptr}.
    \item[{\sf n\_indices}] ({\sf IN}) Integer value holding the number of 
                   elements in the array pointed to by \arg{indices}.
    \item[{\sf n\_values}] ({\sf IN}) Integer value holding the number of 
                   elements in the array pointed to by \arg{values}.
    \item[{\sf format}] ({\sf IN}) a value indicating the format of the matrix 
                   being imported, as defined in Section~\ref{Sec:GrB_Format}.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully and the input arrays have been consumed. 
    Either way, output matrix {\sf A} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The {\sf GrB\_Type} object has not 
    been initialized by a call to {\sf GrB\_Type\_new} (needed for user-defined types).
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf A}, {\sf indptr}, 
    {\sf indices} or {\sf values} pointer is {\sf NULL}.

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}] A value in {\sf indptr} or
    {\sf indices} is outside the allowed range for indices in {\sf A} and or 
    the size of values, {\sf n\_values}, depending on the value of \arg{format}.

    \item[{\sf GrB\_INVALID\_VALUE}] {\sf nrows} or {\sf ncols} is zero or 
    outside the range of the type {\sf GrB\_Index}.
    
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]  The domain given in parameter {\sf d} does
    not match the element type of {\sf values}.
\end{itemize}

\paragraph{Description}

Creates a new matrix $\matrix{A}$ of domain $\mathbf{D}({\sf d})$ and dimension
{\sf nrows $\times$ ncols}. The new GraphBLAS matrix will be filled with the
contents of the matrix pointed to by \arg{indptr}, and \arg{indices}, and \arg{values}.
The method returns a handle to the new matrix in {\sf A}.  The structure of
the data being imported is defined by \arg{format}, which must be equal to
one of the values defined in Section~\ref{Sec:GrB_Format}.  Details of the contents
of \arg{indptr}, \arg{indices} and \arg{values} for each supported format is given in 
Appendix~\ref{App:Matrix_format_details}.

It is not an error to call this method more than once on the same output matrix;  
however, the handle to the previously created object will be overwritten. 

%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_serializeSize}: Compute the serialize buffer size}
\label{Sec:Matrix_serializeSize}

Compute the buffer size (in bytes) necessary to serialize a {\sf GrB\_Matrix} using {\sf GrB\_Matrix\_serialize}.

\paragraph{\syntax}

\begin{Verbatim}[samepage=true]
        GrB_Info GrB_Matrix_serializeSize(GrB_Index  *size,
                                          GrB_Matrix  A);
\end{Verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf size}] ({\sf OUT}) Pointer to {\sf GrB\_Index} value where size in bytes of serialized object will be written.
    \item[{\sf A}]      ({\sf IN}) A GraphBLAS matrix object.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         The operation completed successfully and
       the value pointed to by {\sf *size} has been computed and is ready to use.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf size} is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Returns the size in bytes of the data buffer necessary to serialize the
GraphBLAS matrix object {\sf A}.  Users may then allocate a buffer of {\sf size}
bytes to pass as a parameter to {\sf GrB\_Matrix\_serialize}.

%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_serialize}: Serialize a GraphBLAS matrix.}
\label{Sec:Matrix_serialize}

Serialize a GraphBLAS Matrix object into an opaque stream of bytes.

\paragraph{\syntax}

\begin{Verbatim}[samepage=true]
        GrB_Info GrB_Matrix_serialize(void       *serialized_data,
                                      GrB_Index  *serialized_size,
                                      GrB_Matrix  A);
\end{Verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf serialized\_data}] ({\sf INOUT}) Pointer to the preallocated buffer where the serialized matrix will be written.
    \item[{\sf serialized\_size}] ({\sf INOUT}) On input, the size in bytes of the buffer pointed to by {\sf serialized\_data}. On output, the number of bytes written to {\sf serialized\_data}.
    \item[{\sf A}]      ({\sf IN}) A GraphBLAS matrix object.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
 
  \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully. This indicates that the compatibility tests on 
    the input argument passed successfully, and the output buffer {\sf serialized\_data}
    and {\sf serialized\_size}, have been computed and are ready to use.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf serialized\_data} or {\sf serialize\_size} is {\sf NULL}.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to any matrix constructor.

    \item[{\sf GrB\_INSUFFICIENT\_SPACE}]  The size of the buffer {\sf serialized\_data} (provided as an input {\sf serialized\_size}) was not large enough.
\end{itemize}

\paragraph{Description}

Serializes a GraphBLAS matrix object to an opaque buffer.  To guarantee
successful execution, the size of the buffer pointed to by {\sf serialized\_data},
provided as an input by {\sf serialized\_size}, must be of at least the number
of bytes returned from {\sf GrB\_Matrix\_serializeSize}.  The actual size of the
serialized matrix written to {\sf serialized\_data} is provided upon completion
as an output written to {\sf serialized\_size}.

The contents of the serialized buffer are implementation defined.  Thus, a
serialized matrix created with one library implementation is not necessarily
valid for deserialization with another implementation.

%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_deserialize}: Deserialize a GraphBLAS matrix.}
\label{Sec:Matrix_deserialize}

Construct a new GraphBLAS matrix from a serialized object.

\paragraph{\syntax}

\begin{Verbatim}[samepage=true]
        GrB_Info GrB_Matrix_deserialize(GrB_Matrix  *A,
                                        GrB_Type     d,
                                        const void  *serialized_data,
                                        GrB_Index    serialized_size);
\end{Verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf A}]      ({\sf INOUT}) On a successful return, contains a handle to the newly created GraphBLAS matrix.
    \item[{\sf d}]      ({\sf IN}) the type of the matrix that was serialized in {\sf serialized\_data}. \\
                        If {\sf d} is {\sf GrB\_NULL}, the implementation must attempt to deserialize the matrix without a provided type object.
    \item[{\sf serialized\_data}] ({\sf IN}) a pointer to a serialized GraphBLAS matrix created with {\sf GrB\_Matrix\_serialize}.
    \item[{\sf serialized\_size}]  ({\sf IN}) the size of the buffer pointed to by {\sf serialized\_data} in bytes.
\end{itemize}
\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf A} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}]  This is returned if {\sf serialized\_data}
    is invalid or corrupted.
    
    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The {\sf GrB\_Type} object has not 
    been initialized by a call to {\sf GrB\_Type\_new} (needed for user-defined types).
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf serialized\_data} or {\sf A} is {\sf NULL}.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]  The type given in {\sf d} does not match the type of the matrix serialized
    in {\sf serialized\_data}, or {\sf GrB\_NULL} was passed in and the implementation is unable to construct the
    matrix without the explicitly provided {\sf GrB\_Type}.
\end{itemize}

\paragraph{Description}

Creates a new matrix $\matrix{A}$ using the serialized matrix object pointed to
by {\sf serialized\_data}.  The object pointed to by {\sf serialized\_data}
must have been created using the method {\sf GrB\_Matrix\_serialize}.  The domain
of the matrix is given as an input in {\sf d}, which must match the domain of the
matrix serialized in {\sf serialized\_data} or be {\sf GrB\_NULL}.  Note that for user-defined types,
only the size of the type will be checked.

Since the format of a serialized matrix is implementation-defined, it is not
guaranteed that a matrix serialized in one library implementation can be
deserialized by another.

It is not an error to call this method more than once on the same output matrix;  
however, the handle to the previously created object will be overwritten. 
