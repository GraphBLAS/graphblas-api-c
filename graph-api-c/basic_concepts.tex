\chapter{Basic Concepts}
\label{Chp:Concepts}

The GraphBLAS C API is used to construct  
graph algorithms expressed ``in the language of linear algebra''
%\cite{KepGil2011}.
Graphs are expressed as matrices and the operations over 
these matrices are generalized through the use of a
semiring algebraic structure.

In this chapter, we will define the basic concepts used to
define the GraphBLAS C API.  This includes the following elements:
\begin{itemize}
\item Glossary of terms used in this document.  

\item Algebraic structures and associated arithmetic foundations of the API.

\item Domains of  elements in the GraphBLAS.  

\item Functions that appear in the GraphBLAS algebraic 
structures and how they are managed.

\item Indices, index arrays and scalar arrays used
to expose the contents of GraphBLAS objects.  

\item The execution and error models implied by the GraphBLAS C specification.

\end{itemize}

\section{Glossary}

\glossBegin

\glossItem{application} A program that calls methods from the GraphBLAS C API to
solve a problem.

\glossItem{context} The GraphBLAS C API was designed with the expectation that
implementations of the API might utilize sophisticated execution strategies 
to optimize performance.   We anticipate that an application may need 
to apply constraints on the behavior of implementations of the 
GraphBAS C API and that these constraints may vary from one application 
to another.   To the application, it appears as if the application 
interacts with a distinct instance of the GraphBLAS C API implementation.
The state of this instance is called the GraphBLAS \emph{context}. 
The context  is set with {\sf GrB\_init()}. Currently, the only
supported constraints on a context pertain to the mode of program execution.

\glossItem{GraphBLAS object}  A instance of a data structure defined by the GraphBLAS C
API that is opaque and manipulated only through the API.  The fact the object
is based on an opaque datatype gives an implementation of the GraphBLAS C API
flexibility to optimize data structures for a particular platform.

\glossItem{non-opaque} Any datatype that exposes its internal structure.   This contrasts
with an \emph{opaque} datatype which hides its internals structure and can only
be manipulated through an API.

\glossItem{domain} The set of valid values for the elements of a GraphBLAS object.

\glossItem{method} A function defined in the GraphBLAS C API that manipulates
GraphBLAS objects or other opaque features of the implementation of the GraphBLAS API.

\glossItem{GraphBLAS operators} Binary or unary operators that act on elements of GraphBLAS objects.  \emph{GraphBLAS operators} are used to express algebraic structures used in the GraphBLAS such as monoids and semirings. There are two types of \emph{GraphBLAS operators}: (1) predefined operators found in Table~\ref{Tab:PredefinedOperators} and (2) user-defined operators using {\sf GrB\_UnaryOp\_new()} or {\sf GrB\_BinaryOp\_new()} (see Section~\ref{Sec:AlgebraMethods}).

\glossItem{GraphBLAS operation} A mathematical operation defined in the
GraphBLAS mathematical specification. These operations (not to be confused with \emph{operators}) typically act
on matrices and vectors with elements defined in terms of an algebraic semiring. 

\glossItem{function} The term \emph{function} as used in the GraphBLAS specification
refers to a named group of statements in the C programming language.  Methods, operators,
and user-defined functions are typically implemented as C functions and when referring to 
the code programmers write as opposed to their role as an element of the GraphBLAS, they may
be referred to as such.

\glossItem{implementation defined} Behavior that must be documented
by the implementation and is allowed to vary among different
compliant implementations. 

\glossItem{program order} The text of an application program defines an order
of the GraphBLAS methods. This order is called the \emph{program order}.

\glossItem{sequence} A \emph{sequence} is a series of GraphBLAS method calls in program order.  
An implementation of the GraphBLAS may reorder or even fuse GraphBLAS methods within a 
sequence as long as the definitions of any GraphBLAS object that are later read by an application 
are not changed; where by ``read'' we mean that values are copied from an opaque GraphBLAS 
object into a non-opaque object.  A sequence begins when a thread calls the first method that creates
or modifies a GraphBLAS object either (1) the first call in an application or (2) the first call 
following termination of a prior sequence.  The only way to terminate a sequence within an 
application is with a call to the GrB\_wait() method. 
%\glossItem{sequence} A sequence of GraphBLAS method calls that fully defines the value of 
%a GraphBLAS object.  The sequence for a particular GraphBLAS object is defined 
%by a series of GraphBLAS method calls in program order that: (1) \emph{begins} with 
%the first GraphBLAS method that creates or modifies the GraphBLAS object; 
%and (2) \emph{terminates} with a GraphBLAS method that explicitly waits for the series of 
%methods to complete or the first method that reads values from the GraphBLAS 
%object and writes them into a non-opaque object.

\glossItem{complete} A GraphBLAS object is fully defined by the sequence of methods.   
The execution of a sequence may be deferred, however, so at any point 
in an application, a GraphBLAS object may not be materialized; that is, 
the values associated with a particular GraphBLAS object may not have 
been computed and stored in memory.   We say that a GraphBLAS object is \emph{complete} 
when the computations that implement the mathematical definition of the object have 
finished and the values associated with that object are available to any method that would 
load them into a non-opaque data structure.   Essentially, methods that extract elements 
from an opaque object and copy them into a non-opaque object force \emph{completion} of the
opaque object. 

\glossItem{materialize} A GraphBLAS object has been \emph{materialized} when 
the computations that implement the mathematical definition of the object 
have finished and the values associated with that object reside in memory.   
A GraphBLAS object that is never loaded into a non-opaque data structure may 
potentially never be materialized.  This might happen, for  example, should the operations 
associated with the object be fused or otherwise changed by the runtime system 
that supports the implementation of the GraphBLAS C API.   

\glossItem{mode} A GraphBLAS sequence executes in one of two modes.  
In \emph{blocking mode}, GraphBLAS methods return after the computations 
complete and any output objects have been updated.  In nonblocking mode, a 
method returns once the arguments are tested as consistent with 
the method but potentially before any computation has proceeded.

\glossItem{monoid} An algebraic structure consisting of a domain, an 
associative\footnote{We expect implementations of the GraphBLAS C API
to use floating point arithmetic such as that defined by the IEEE-754 standard.
Floating point arithmetic is not strictly associative.}
binary operator, and an identity corresponding to that 
operator.

\glossItem{semiring} An algebraic structure consisting of a set of allowed values
(the \emph{domain}), two commutative binary operators called \emph{addition} 
and \emph{multiplication} over which the distributive property holds, identities 
over addition (\emph{0}) and multiplication (\emph{1}), and finally the additive
identity is an annihilator over multiplication.   
Note that a \emph{GraphBLAS semiring} is allowed to diverge from the mathematically 
rigorous definition of a semiring since certain combinations of domains, operators and identity 
elements are useful in graph algorithms even when they do not strictly match the mathematical
definition of a semiring.

\glossItem{structural zero} Also known as an \emph{implied zero}, a \emph{structural zero} is any element which has a valid index (or indices) in a GraphBLAS vector or matrix but is not explicitly identified in the list of elements of that vector or matrix. From a mathematical perspective, a \emph{structural zero} is treated as having the value of the zero element of the relevant monoid or semiring.

\glossItem{structural complement} The \emph{structural complement} of a GraphBLAS vector or matrix of any domain is another vector or matrix, of domain {\tt bool}, in which the explicitly identified elements (with a value of {\tt true}) are the \emph{structural zeroes} of the original vector or matrix (which have an implied value of {\tt false}). 

\glossItem{thread safe} A routine is said to be \emph{thread safe} if it performs its intended 
function even when executed concurrently (by more than one thread).

\glossItem{shape consistent} Also referred to as \emph{dimension consistent}, the relevant GraphBLAS method is \emph{shape consistent} if the operation being performed satisfies the dimension rules of its linear algebraic equivalent.

\glossItem{domain consistent} Two domains are \emph{domain consistent} with each other if values from one domain can be cast to values in the other domain as per the rules of the C language. In particular, domains from Table~\ref{Tab:PredefinedTypes} are all consistent with each other. A domain from a user-defined type is only consistent with itself. If any \emph{domain consistency} rule above is violated, execution of GraphBLAS method ends and the domain mismatch error listed above is returned.

\glossEnd

\section{Notation}

\begin{tabular}{l|p{5in}}
Notation & Description \\
\hline
$D_i$           & The $i$th domain of a GraphBLAS object. \\
$\bold{D}_i(*)$ & Evaluates to the $i$th domain of the object passed (usually a unary or binary operator, or semiring). \\
$\bold{D}(*)$   & Evaulates to the (only) domain of the object passed (usually a monoid, vector or matrix). \\ 
$f$             & An arbitrary unary function, usually a component of a unary operator. \\
$\bold{f}(F_u)$ & Evaluates to the unary function contained in the unary operator given as the argument. \\
$\odot$         & An arbitrary binary function, usually a component of a binary operator. \\
$\bold{\bigodot}(*)$ & Evaluates to the binary function contained in the binary operator or monoid given as the argument. \\
$\otimes$       & Multiplicative binary operator of a semiring. \\
$\oplus$        & Additive binary operator of a semiring. \\
$\bold{\bigotimes}(S)$ & Evaluate to the multiplicative binary operator of the Semiring given as the argument. \\
$\bold{\bigoplus}(S)$ & Evaluate to the additive binary operator of the Semiring given as the argument. \\
$\bold{0}(*)$   & The identity of a monoid, or the additive identity of a GraphBLAS Semiring. \\
$\bold{L}(*)$   & The contents (all stored values) of the vector or matrix given as an argument.  For vector, it is a set of (index, value) 2-ples and for a matrix it is the set of (row, col, value) triples. \\
$\bold{v}(i)$   & The $i^{th}$ element of the vector $\vector{v}$.\\
$v_i$           & The $i^{th}$ element of the vector $\vector{v}$.\\
$\bold{size}(\vector{v})$ & The size of the $\vector{v}$.\\
$\bold{ind}(\vector{v})$ & The set of indices corresponding to the stored values of the vector $\vector{v}$.\\
$\bold{nrows}(\vector{A})$ & The number of rows in the $\matrix{A}$.\\
$\bold{ncols}(\vector{A})$ & The number of columns in the $\matrix{A}$.\\
$\bold{indrow}(\vector{A})$ & The set of indices corresponding to the stored values of the indicated row  \\
$\bold{indcol}(\vector{A})$ & The set of indices corresponding to the stored values of the indicated column \\
$\bold{ind}(\vector{A})$ & The set of $(i,j)$ indices corresponding to the stored values of the matrix \\
$\bold{A}(i,j)$ & The element of $\matrix{A}$ with row index $i$ and column index $j$.\\
$A_{ij}$ & The element of $\matrix{A}$ with row index $i$ and column index $j$.\\
$\matrix{A}(:,j)$ & The $j^{th}$ column of the the matrix $\matrix{A}$.\\
$\matrix{A}(i,:)$ & The $i^{th}$ row of the the matrix $\matrix{A}$.\\
$\matrix{A}^T$ &The transpose the matrix $\matrix{A}$. \\
$\neg\matrix{M}$ & The structural compliment of $\matrix{M}$.\\
$\vector{\widetilde{t}}$ & The object $\vector{t}$ is a temporary copy created  by the GraphBLAS implementation. \\

\end{tabular}

\section{Algebraic and Arithmetic foundations}

Graphs can be represented in terms of matrices. Operations defined by the GraphBLAS standard
operate on these matrices to construct graph algorithms.
These GraphBLAS operations are defined in terms of GraphBLAS semiring algebraic 
structures. Modifying the underlying semiring changes the result of 
an operation to support a wide range of graph algorithms.

Inside a given algorithm, it is often beneficial to change the GraphBLAS semiring
that applies to an operation on a matrix.  This has two 
implications on the C-binding to the GraphBLAS.  First,
it means that we define a separate object for the semiring 
to pass into functions.  Since in many cases the full
semiring is not required, we also support passing monoids or
even operators; which basically means the semiring is implied but not 
explicitly stated.

Second, the ability to change semirings impacts the meaning of 
the \emph{implied zero} in a sparse representation of a matrix.
This element in real arithmetic is zero which is the 
identity of the \emph{addition} operator and the annihilator of
\emph{multiplication} operator.   As the semiring changes, this 
\emph{implied} or \emph{structural zero} changes to the identity of 
the \emph{addition} operator and the annihilator of the \emph{multiplication} 
operator for the new semiring.   Nothing changes in the
stored matrix, but the implied values within the sparse matrix change
with respect to a particular operation.  In most cases, the nature
of the implied zero does not matter since the GraphBLAS treats these
as elements of the matrix that do not exist.  As we will see, however,
there are a small subset of GraphBLAS methods 
(the element-wise operations) where to understand 
the method you need to understand the implied zero.

The mathematical formalism for graph operations in the language of 
linear algebra assumes that we can operate in the field of real numbers. 
However, the GraphBLAS C binding is designed for implementation on computers 
which by necessity have a finite number of bits to represent numbers. 
Therefore, we require a conforming implementation to use floating-point 
number such as those defined by the IEEE-754 standard (both single- and double-precision) 
wherever real numbers need to be represented. The practical implications of 
these finite precision numbers is that the result of a sequence of 
computations may vary from one execution to the next as the way 
operations are associated change. While techniques are known to 
reduce these effects, we do not require or even expect an implementation 
to use them as they may add considerable overhead. The fact is that in most 
cases, these roundoff errors are not significant and when they are significant, 
the problem itself is ill-conditioned and needs to be reformulated.

\section{Domains}

GraphBLAS defines two kinds of collections: matrices and vectors.
For any given collection, the elements of the collection belong to
a \emph{domain}, which is the set of valid values for the elements.
In GraphBLAS, domains correspond to the valid values for types from
the host language (in our case, the C programming language).  For any
variable or object $V$ in GraphBLAS we denote as $\bold{D}(V)$ the
domain of $V$; that is, the set of possible values that elements of
$V$ can take.  The predefined types and corresponding domains used in the 
GraphBLAS are shown in Table~\ref{Tab:PredefinedTypes}.  The Boolean
type is defined in {\tt stdbool.h}, the integral types are defined in
{\tt stdint.h}, and the floating-point types are native to the language
and in most cases defined by the IEEE-754 standard.
%GraphBLAS also supports user defined types. In that case, the domain is
%the set of valid values for a variable of that type.

\begin{table}
\hrule
\begin{center}
\caption{Predefined {\sf GrB\_Type} values, the corresponding C type (for scalar
parameters, and domains for GraphBLAS.}
\label{Tab:PredefinedTypes}
\begin{tabular}{l|l|l}
{\sf GrB\_Type values} & C type            & domain \\
\hline
{\sf GrB\_BOOL}        & {\tt bool}        & $\{ {\tt false}, {\tt true} \}$  \\
{\sf GrB\_INT8}        & {\tt int8\_t}     & $\mathbb{Z} \cap [-2^{7},2^{7})$  \\
{\sf GrB\_UINT8}       & {\tt uint8\_t}    & $\mathbb{Z} \cap [0,2{^8})$  \\
{\sf GrB\_INT16}       & {\tt int16\_t}    & $\mathbb{Z} \cap [-2^{15},2^{15})$ \\
{\sf GrB\_UINT16}      & {\tt uint16\_t}   & $\mathbb{Z} \cap [0,2^{16})$ \\
{\sf GrB\_INT32}       & {\tt int32\_t}    & $\mathbb{Z} \cap [-2^{31},2^{31})$ \\
{\sf GrB\_UINT32}      & {\tt uint32\_t}   & $\mathbb{Z} \cap [0,2^{32})$ \\
{\sf GrB\_INT64}       & {\tt int64\_t}    & $\mathbb{Z} \cap [-2^{63},2^{63})$ \\
{\sf GrB\_UINT64}      & {\tt uint64\_t}   & $\mathbb{Z} \cap [0,2^{64})$ \\
{\sf GrB\_FP32}        & {\tt float}       & IEEE 754 {\sf binary32}  \\
{\sf GrB\_FP64}        & {\tt double}      & IEEE 754 {\sf binary64}  \\
\end{tabular}
\end{center}
\hrule
\end{table}

\section{Operators and Associated Functions}

GraphBLAS operators act on elements of GraphBLAS objects.   A
 \emph{binary operator} is a function that maps two input
values to one output value. A \emph{unary operator} is a function that 
maps one input value to one output value. The value of the output is 
determined by the value of the input(s).  Binary operators are defined over 
two input domains and produce an output from a (possibly different) third 
domain. Unary operators are specified over one input domain and produce an 
output from a (possibly different) second domain.

Similar to GraphBLAS types having predefined types and user-defined types, 
GraphBLAS operators come in two types as well: (1) predefined operators 
found in Table~\ref{Tab:PredefinedOperators} and (2) user-defined operators 
using {\sf GrB\_UnaryOp\_new()} or {\sf GrB\_BinaryOp\_new()} (see Section~\ref{Sec:AlgebraMethods}).

\begin{table}
\hrule
\begin{center}
\caption{Predefined unary and binary operators for GraphBLAS in C.}
\label{Tab:PredefinedOperators}

\vspace{1\baselineskip}
(a) Valid suffixes and corresponding C type ($T$ in table (b)).
\vspace{1\baselineskip}

\begin{tabular}{l|l}
Suffix			& C type \\ \hline
{\sf BOOL}		& {\tt bool} \\
{\sf INT8}		& {\tt int8\_t} \\
{\sf UINT8}		& {\tt uint8\_t} \\
{\sf INT16}		& {\tt int16\_t} \\
{\sf UINT16}	& {\tt uint16\_t} \\
{\sf INT32}		& {\tt int32\_t} \\
{\sf UINT32}	& {\tt uint32\_t} \\
{\sf INT64}		& {\tt int64\_t} \\
{\sf UINT64}	& {\tt uint64\_t} \\
{\sf FP32}		& {\tt float} \\
{\sf FP64}		& {\tt double} \\
\end{tabular}

\vspace{1\baselineskip}
(b) Predefined Operators.
\vspace{1\baselineskip}

\begin{tabular}{l|l|l|ll}
Operator & GraphBLAS             &                                                              & \\
type     & identifier            & Domains                                              & Description \\ \hline
{\sf GrB\_UnaryOp}    & {\sf GrB\_IDENTITY\_$T$} & $T \rightarrow T $     & $f(x) = x$, &identity \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_AINV\_$T$}     & $T \rightarrow T $     & $f(x) = -x$, &additive inverse \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_MINV\_$T$}     & $T \rightarrow T $     & $f(x) = \frac{1}{x}$, &multiplicative inverse \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_LNOT}          & ${\tt bool} \rightarrow {\tt bool}$  & $f(x) =~\neg x$, &logical inverse  \\

&&&\\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LOR}        & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = x \lor y$, & logical OR \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LAND}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = x \land y$, & logical AND \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LXOR}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = x \oplus y$, & logical XOR \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_EQ\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x == y)$ & equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_NE\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x \neq y)$ & not equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_GT\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x > y)$ & greater than  \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LT\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x < y)$ & less than  \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_GE\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x \geq y)$ & greater than or equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LE\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x \leq y)$ & less than or equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_FIRST\_$T$} & $T \times T \rightarrow T$  & $f(x,y) = x$, & first argument \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_SECOND\_$T$}& $T \times T \rightarrow T$  & $f(x,y) = y$, & second argument \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_MIN\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = (x < y)~?~x : y$, & minimum \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_MAX\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = (x > y)~?~x : y$, & maximum \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_PLUS\_$T$}  & $T \times T \rightarrow T$  & $f(x,y) = x + y$, & addition \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_MINUS\_$T$} & $T \times T \rightarrow T$  & $f(x,y) = x - y$, & subtraction \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_TIMES\_$T$} & $T \times T \rightarrow T$  & $f(x,y) = xy$, & multiplication \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_DIV\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = \frac{x}{y}$, & division \\
\end{tabular}
\end{center}
\hrule
\end{table}

%% TGM:  I think we should call this section 'non opaque types and constants
%\section{Indices, Index Arrays and Scalar Arrays}
\section{Non-opaque Objects, Non-opaque Types, and Literals}


In order to interface with third-party software (i.e. software other than
an implementation of the GraphBLAS), operations 
such as {\sf GrB\_Matrix\_build} (\S~\ref{Sec:Matrix_build}) and
{\sf GrB\_Matrix\_extractTuples} (\S~\ref{Sec:Matrix_extractTuples}) must specify
how the data should be laid out in  non-opaque data structures.  To 
this end we define, explicitly the types for indices and the arrays 
used by these operations.

For indices a typedef is used to give a GraphBLAS name to a concrete type. We define it as follows:

\begin{verbatim}
    typedef uint64_t GrB_Index;
\end{verbatim}

An index array is a pointer to a set of {\sf GrB\_Index} values that are 
stored in a contiguous block of memory (\ie, {\sf GrB\_Index*}).
Likewise a scalar array is a pointer to a contiguous block of memory 
storing a number of scalar values as specified by the user.
For any GraphBLAS method that uses an input index array, the literal {\sf GrB\_ALL} 
can be used to indicate that all indices of the associated GraphBLAS object should be used.


The arguments to GraphBLAS methods utilize a range of types.  Types
associated with GraphBLAS objects an operators were defined earlier.
the following table lists any remaining types found in the signature 
of a GraphBLAS method.  
\begin{itemize}
\item {\sf GrB\_Mode} from {\sf init}
\item {\sf GrB\_Field} from descriptor methods
\item {\sf GrB\_Value} from descriptor methods
\item {\sf GrB\_Descriptor}
\item {\sf GrB\_Type} A user defined  or one of the GraphBLAS predefined types.
\item {sf GrB\_Object} One of the types for a GraphBLAS object.
\item {\sf GrB\_BinaryFunction} see {\sf GrB\_extract} matrix variant. Shouldn't this be {\sf GrB\_BinaryOp}?
\end{itemize}

GraphBLAS methods make use of a number of  literals.  Literals associated with
return values are defined later.  All other literals are defined in the following table.
Many of these pertain to descriptors which are used to modify the behavior of a
GraphBLAS method.  In the text of this specification  we often refer to these
using the notation {\sf desc[Field].Value}.
\begin{itemize}
\item {\sf GrB\_NULL} The GraphBLAS NULL, 
\item {\sf GrB\_ALL} Specifies that all indices associated with a GraphBLAS object should be used.
\item {\sf GrB\_BLOCKING} Specifies the blocking mode context.
\item {\sf GrB\_NONBLOCKING} Specifies the blocking mode context.
\item {\sf GrB\_OUTP} The descriptor field name for the output GraphBLAS object. 
\item {\sf GrB\_INP0} The descriptor field name for the first input GraphBLAS object. 
\item {\sf GrB\_INP1} The descriptor field name for the second input  GraphBLAS object. 
\item {\sf GrB\_MASK}The descriptor field name for the mask GraphBLAS object. 
\item {\sf GrB\_SCMP} Descriptor field value, use the structural compliment of the associated object.
\item {\sf GrB\_TRAN} Descriptor field value, use the transpose compliment of the associated object.
\item {\sf GrB\_REPLACE} Descriptor field value, clear the output object before assigning computed value.
\end{itemize}

\section{Execution Model}

A program using the GraphBLAS C API constructs GraphBLAS objects,
manipulates them to implement a graph algorithm, and then extracts
values from the GraphBLAS objects as the result of the algorithm.
Functions defined within the GraphBLAS C API that manipulate GraphBLAS
objects are called \emph{methods}.  If the method corresponds to one
of the operations defined in the GraphBLAS mathematical specification,
we refer to the method as an \emph{operation}.

Graph algorithms are expressed as an ordered collection of GraphBLAS
method calls defined by the order they are encountered in a program.
This is called the \emph{program order}.  Each method in the collection
uniquely and unambiguously defines the output GraphBLAS objects based
on the GraphBLAS operation and the input GraphBLAS objects. (As long
as there are no execution errors. Execution errors can put objects in
invalid states. See \S~\ref{Sec:ErrorModel}.)

The program order of GraphBLAS method calls is broken down into
contiguous and nonoverlapping \emph{sequences}.  A sequence is an
ordered collection of method calls by an executing thread. (For more
on threads and GraphBLAS, see \S~\ref{Sec:ThreadSafety}.)  A sequence
begins with either (i) the first GraphBLAS method called by a thread, or
(ii) the first method called by a thread after the end of the previous
sequence. A sequence always ends (terminates) with a call to the GraphBLAS
{\sf GrB\_wait()} method.

The GraphBLAS objects are fully defined at any point in the sequence by the
methods in the sequence, as long as there are no execution errors.
In particular, as soon as a GraphBLAS
method call returns, its output can be used in the next GraphBLAS
method call.  However, individual operations in a sequence may not
be \emph{complete}. We say that an operation is complete when all the
computations in the operation have finished and all the values of its
output object have been produced and committed to the address 
space of the program.

The opaqueness of GraphBLAS objects allows execution to proceed
from one method to the next even when operations are not complete.
Processing of nonopaque objects is never deferred in GraphBLAS. That is,
methods that consume nonopaque objects (\eg, {\sf GrB\_Matrix\_build},
\S~\ref{Sec:Matrix_build}()) and methods that produce nonopaque objects (\eg,
{\sf GrB\_Matrix\_extractTuples()}, \S~\ref{Sec:Matrix_extractTuples})
always finish consuming or producing those nonopaque objects before
returning. 
Furthermore, methods that extract values from opaque GraphBLAS objects
into nonopaque user objects (see Table~\ref{Tab:ExtractMethods})
always force completion of all pending computations on the 
corresponding GraphBLAS source object.

\begin{table}[htb]
	\hrule
	\begin{center}
		\caption{Methods that extract values from GraphBLAS objects.}
		\label{Tab:ExtractMethods}

		\begin{tabular}{l|l}
			Method	& Section \\ \hline

			{\sf GrB\_Vector\_nvals}		& \S~\ref{Sec:Vector_nvals}		\\
			{\sf GrB\_Vector\_extractTuples}	& \S~\ref{Sec:Vector_extractTuples}	\\
			{\sf GrB\_Matrix\_nvals}		& \S~\ref{Sec:Matrix_nvals}		\\
			{\sf GrB\_Matrix\_extractTuples}	& \S~\ref{Sec:Matrix_extractTuples}	\\
			{\sf GrB\_extract} (single element vector variant)	& \S~\ref{Sec:extract_single_element_vec}	\\
			{\sf GrB\_extract} (single element matrix variant)	& \S~\ref{Sec:extract_single_element_mat}	\\
			{\sf GrB\_reduce} (vector-scalar variant)		& \S~\ref{Sec:Reduce_vector_scalar}		\\
			{\sf GrB\_reduce} (matrix-scalar variant)		& \S~\ref{Sec:Reduce_matrix_scalar}		\\
		\end{tabular}
	\end{center}
	\hrule
\end{table}

\subsection{Execution modes}

The execution model
implied by GraphBLAS sequences depends on the \emph{execution mode} of the 
GraphBLAS program.  There are two modes: \emph{blocking} and \emph{nonblocking}.  
\begin{itemize}

\item \emph{blocking}: In blocking mode, each method completes the
GraphBLAS operation defined by the method before proceeding to the
next statement in program order.  Output GraphBLAS objects defined by a
method are fully produced and stored in  memory (\ie, they are
\emph{materialized}).  In other words, it is as if each method call is its own sequence.
Even mechanisms that break the opaqueness of the
GraphBLAS objects (\eg, performance monitors, debuggers, memory dumps)
will observe the operation as complete.

\item \emph{nonblocking}: In nonblocking mode, each method may return
once the input arguments have been inspected and verified to define a
well formed GraphBLAS operation. (That is, there are no API errors. See
\S~\ref{Sec:ErrorModel}.) The GraphBLAS operation may not have completed,
but the output object is ready to be used by the next GraphBLAS method
call.  Completion of \emph{all} operations in a sequence, including any that may generate execution
errors, can only be guaranteed when the sequence terminates through a
call to {\sf GrB\_wait()}.

\end{itemize}

An application executing in nonblocking mode is not required to return
immediately after input arguments have been verified. A conforming
implementation of the GraphBLAS C API running in nonblocking mode may
choose to execute ``as if'' in blocking mode.  Further, a sequence in
nonblocking mode where every GraphBLAS operation is followed by an {\sf
GrB\_wait()} call is equivalent to the same sequence in blocking mode
with {\sf GrB\_wait()} calls removed.

Nonblocking mode allows for any execution strategy that satisfies the
mathematical definition of the sequence.  The methods can be placed
into a queue and deferred.  They can be chained together and fused
(\eg, replacing a chained pair of matrix products with a matrix triple
product).  Lazy evaluation, greedy evaluation or asynchronous execution
are all valid as long as the final result agrees with the mathematical
definition provided by the sequence of GraphBLAS method calls appearing
in  program order.

Blocking mode forces an implementation to carry out precisely the
GraphBLAS operations defined by the methods and to store output objects
to memory between method calls.  It is valuable for debugging or in
cases where an external tool such as a debugger needs to evaluate the
state of memory during a sequence.

In a  mathematically well-defined sequence with input objects that
are well-conditioned, and free of execution errors, the results from
blocking and nonblocking modes should be identical outside of effects
due to round-off errors associated with floating point arithmetic.
Due to the great flexibility afforded to an implementation when using
nonblocking mode, we expect execution of a sequence in nonblocking mode
to potentially complete execution in less time.

The mode is defined in the GraphBLAS C API when the context of the
library invocation is defined.  This occurs once before any GraphBLAS
methods are called with a call to the {\sf GrB\_init()} function.
After all GraphBLAS methods are complete, the context is terminated
with a call to {\sf GrB\_finalize()}.  In the current version of the
GraphBLAS C API, the context can only be set once in the execution of
a program. That is, after {\sf GrB\_finalize()} is called a following
call to {\sf GrB\_init()} is not allowed.


\subsection{Thread safety}
\label{Sec:ThreadSafety}

Implementations of the GraphBLAS C API are required to be thread safe.  Different threads 
may create GraphBLAS sequences that do not conflict and expect the results to be the 
same (within floating point roundoff errors) regardless of whether the sequences execute serially or concurrently.

Sequences that do not conflict are free of data races.  A data race occurs
when: (1) two or more threads access shared objects, (2) those access 
operations include at least one modify operation,
and (3) those operations are not ordered through synchronization operations.   
The GraphBLAS C API does not provide synchronization operations to define 
ordered accesses to GraphBLAS objects. Hence the only way to assure that 
two sequences running concurrently on different threads do not 
conflict is if neither sequence writes to an object that the other 
sequence either reads or writes.

\section{Error Model}
\label{Sec:ErrorModel}

All GraphBLAS methods return a value of type {\sf GrB\_Info} to provide
information available to the system at the time the method returns.  The
returned value can be either {\sf GrB\_SUCCESS} or one of the defined
error values shown in Table~\ref{Tab:ErrorValues}. The errors fall into
two groups: API errors (Table~\ref{Tab:ErrorValues}(a)) and execution
errors (Table~\ref{Tab:ErrorValues}(b)).

An API error means a GraphBLAS method was called with parameters that
violate the rules for that method. API errors are deterministic and
consistent across platforms and implementations.  API errors are never
deferred, even in nonblocking mode. That is, if a method is called in a manner
that would generate an API error, it always returns with the appropriate API error value.  
If a GraphBLAS method returns with an API error, it is guaranteed that none of the
arguments to the method (or any other program data) have been modified.

Execution errors indicate that something went wrong during the execution
of a legal GraphBLAS method invocation.  Their occurrence may depend on
specifics of the executing environment.  This does not mean that execution
errors are the fault of the GraphBLAS implementation.  For example, a
memory leak could arise from an error in an application's source code (a 
``program error'') but it may manifest itself in different
points of a program's execution (or not at all) depending on the platform,
problem size, or what else is running at that time.  Index-out-of-bounds
execution errors always indicate a program error.

In blocking mode, where each method executes to completion, a returned
execution error value applies to the specific method.  If a GraphBLAS
method, executing in blocking mode, returns with a {\sf GrB\_OUT\_OF\_MEMORY} or
a {\sf GrB\_INDEX\_OUT\_OF\_BOUNDS} error, it is guaranteed that no argument
used as input-only has been modified. Output arguments may be left in
an invalid state and their use downstream in the program flow may cause
additional errors.  If a GraphBLAS method returns with a {\sf GrB\_PANIC},
no guarantees can be made about the state of any program data.

In nonblocking mode, execution errors can be deferred.  A return value
of {\sf GrB\_SUCCESS} only guarantees that there are no API errors in the
method invocation.  If an execution error value is returned by a method in
nonblocking mode, it indicates that an error was found during execution
of the sequence, up to and including the {\sf GrB\_wait()} method call
that ends the sequence.  When possible, that return value will provide
information concerning the cause of the error.  

If a GraphBLAS method, executing in nonblocking mode, returns
with a {\sf GrB\_OUT\_OF\_MEMORY} or a {\sf GrB\_INDEX\_OUT\_OF\_BOUNDS} error,
it is guaranteed that no argument used as input-only through the entire
sequence has been modified. Any output argument in the sequence may be
left in an invalid state and its use downstream the program flow may cause
additional errors.  If a GraphBLAS method returns with a {\sf GrB\_PANIC},
no guarantees can be made about the state of any program data.

\begin{table}[htb]
\hrule
\begin{center}
\caption{Error values returned by GraphBLAS methods.}
\label{Tab:ErrorValues}

\vspace{1\baselineskip}
(a) API errors
\vspace{1\baselineskip}

\begin{tabular}{l|p{3in}}
Error code	& Description \\ \hline
{\sf GrB\_UNINITIALIZED\_OBJECT} & A GraphBLAS object is passed to a method before {\sf new} was called on it.\\
{\sf GrB\_NULL\_POINTER} & A NULL is passed for a pointer parameter. \\
{\sf GrB\_INVALID\_VALUE} & Miscellaneous incorrect values. \\
{\sf GrB\_INVALID\_INDEX} & Indices passed are larger than dimensions of matrix or vector being accessed. \\
{\sf GrB\_DOMAIN\_MISMATCH} & A mismatch between domains of collections and operations when user-defined domains are in use.\\
{\sf GrB\_DIMENSION\_MISMATCH} & Operations on matrices and vectors with incompatible dimensions. \\
{\sf GrB\_NO\_VALUE} & A location in a matrix or vector is being access that has no store value at the specified location. \scott{It depends on whether or not the non-opaque scalar is
well-defined on return from {\sf extract}}\\
\end{tabular}

\vspace{1\baselineskip}
(b) Execution errors
\vspace{1\baselineskip}

\begin{tabular}{l|p{3in}}
Error code	& Description \\ \hline
{\sf GrB\_OUT\_OF\_MEMORY}		& Not enough memory for operations. \\
{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}	& Reference to a vector or matrix elements that is outside the defined dimensions of the object. \\
{\sf GrB\_PANIC}		& Unknown internal error. \\
\end{tabular}

\end{center}
\hrule
\end{table}

After a call to any GraphBLAS method, the program can retrieve additional
error information (beyond the error code returned by the method) though a
call to the function {\sf GrB\_error()}. The signature of that function is
shown in Figure~\ref{Fig:GrB_error}.
The function returns a pointer to a null terminated string and the contents of that string
are implementation dependent. In particular, a null string (not a {\sf NULL} pointer) is always a valid error string.
The pointer is valid until the next call to any GraphBLAS method by the same thread.
{\sf GrB\_error()} is a thread-safe function, in the sense that multiple threads can
call it simultaneously and each will get its own error string back, referring to the
last GraphBLAS method it called.

\begin{figure}[htb]
	\hrule
	\vspace{1\baselineskip}
	\begin{center}
		\begin{minipage}{3in}
			\begin{verbatim}
			const char *GrB_error();
			\end{verbatim}
		\end{minipage}
	\end{center}
	\caption{Signature of {\sf GrB\_error()} function.}
	\label{Fig:GrB_error}
	\hrule
\end{figure}
