\chapter{Basic concepts}
\label{Chp:Concepts}

The GraphBLAS C API is used to construct  
graph algorithms expressed ``in the language of linear algebra.''
Graphs are expressed as matrices, and the operations over 
these matrices are generalized through the use of a
semiring algebraic structure.

In this chapter, we will define the basic concepts used to
define the GraphBLAS C API.  We provide the following elements:

\begin{itemize}
\item Glossary of terms and notation used in this document.  
\item Algebraic structures and associated arithmetic foundations of the API.
\item Functions that appear in the GraphBLAS algebraic structures and how they are managed.
\item Domains of elements in the GraphBLAS.
\item Indices, index arrays, scalar arrays, and external matrix formats used to expose the contents of GraphBLAS objects.
\item The GraphBLAS opaque objects. 
\item The execution and error models implied by the GraphBLAS C specification.
\item Enumerations used by the API and their values.
\end{itemize}

\section{Glossary}

%=============================================================================

\subsection{GraphBLAS API basic definitions}

\glossBegin

\glossItem{application} A program that calls methods from the GraphBLAS C API to
solve a problem.

\glossItem{GraphBLAS C API} The application programming interface that fully defines the types, objects, 
literals, and other elements of the C binding to the GraphBLAS.

\glossItem{function} Refers to a named group of statements in the C programming language.  Methods, operators,
and user-defined functions are typically implemented as C functions.
When referring to 
the code programmers write, as opposed to the role of functions as an element of the GraphBLAS, they may
be referred to as such.

\glossItem{method} A function defined in the GraphBLAS C API that manipulates
GraphBLAS objects or other opaque features of the implementation of the GraphBLAS API.

\glossItem{operator} A function that performs an operation on the elements stored in GraphBLAS matrices and vectors.

\glossItem{GraphBLAS operation} A mathematical operation defined in the
GraphBLAS mathematical specification. These operations (not to be confused with \emph{operators}) typically act
on matrices and vectors with elements defined in terms of an algebraic semiring. 
\glossEnd

%=============================================================================

\subsection{GraphBLAS objects and their structure}

\glossBegin
\glossItem{non-opaque datatype} Any datatype that exposes its internal structure and
can be manipulated directly by the user.   

\glossItem{opaque datatype} Any datatype that hides its internal structure and can
be manipulated only through an API.

\glossItem{GraphBLAS object}  An instance of an \emph{opaque datatype} defined 
by the \emph{GraphBLAS C API} that is manipulated only through the GraphBLAS 
API. There are four kinds of GraphBLAS opaque objects: \emph{domains} (i.e., types), 
\emph{algebraic objects} (operators, monoids and semirings), 
\emph{collections} (scalars, vectors, matrices and masks), and descriptors.   

\glossItem{handle}  A variable that holds a reference to an instance of one of 
the GraphBLAS opaque objects.  The value of this variable holds a reference to 
a GraphBLAS object but not the contents of the object itself.  Hence, assigning 
a value to another variable copies the reference to the GraphBLAS object of one 
handle but not the contents of the object.

\glossItem{domain} The set of valid values for the elements stored in a 
GraphBLAS \emph{collection} or operated on by a GraphBLAS \emph{operator}.
Note that some GraphBLAS objects involve functions that map values from 
one or more input domains onto values in an output domain.  These GraphBLAS 
objects would have multiple domains.

\glossItem{collection} An opaque GraphBLAS object that holds a number of
elements from a specified \emph{domain}. Because these objects are based on an 
opaque datatype, an implementation of the GraphBLAS C API has the flexibility 
to optimize the data structures for a particular platform.  GraphBLAS objects 
are often implemented as sparse data structures, meaning only the subset of the
elements that have values are stored.

\glossItem{implied zero}  Any element that has a valid index (or indices) 
in a GraphBLAS vector or matrix but is not explicitly identified in the list of 
elements of that vector or matrix. From a mathematical perspective, an
\emph{implied zero} is treated as having the 
value of the zero element of the relevant monoid or semiring.
However, GraphBLAS operations are purposefully defined using set notation in such a way
that it makes it unnecessary to reason about implied zeros. 
Therefore, this concept is not used in the definition of GraphBLAS methods and operators.

\glossItem{mask} An internal GraphBLAS object used to control how values 
are stored in a method's output object.  The mask exists only inside a method; hence,
it is called an \emph{internal opaque object}.  A mask is formed from the elements of
a collection object (vector or matrix) input as a mask parameter to a method. GraphBLAS 
allows two types of masks:
\begin{enumerate}
\item In the default 
case, an element of the mask exists for each element that exists in the 
input collection object when the value of that element, when cast to a Boolean type, evaluates to 
{\tt true}.  
\item In the {\it structure only} case, masks have structure but no values. 
The input collection describes a structure whereby an 
element of the mask exists for each element stored in the input collection regardless of its value.
\end{enumerate}

\glossItem{complement} The \emph{complement} of a 
GraphBLAS mask, $M$, is another mask, $M'$, where the elements of $M'$
are those elements from $M$ that \emph{do not} exist.  
\glossEnd

%=============================================================================

\subsection{Algebraic structures used in the GraphBLAS}

\glossBegin
\glossItem{associative operator} In an expression where a binary operator is used 
two or more times consecutively, that operator is \emph{associative} if the result 
does not change regardless of the way operations are grouped (without changing their order). 
In other words, in a sequence of binary operations using the same associative 
operator, the legal placement of parenthesis does not change the value resulting 
from the sequence operations.  Operators that are associative over infinitely 
precise numbers (e.g., real numbers) are not strictly associative when applied to 
numbers with finite precision (e.g., floating point numbers). Such non-associativity 
results, for example, from roundoff errors or from the fact some numbers can not 
be represented exactly as floating point numbers.   In the GraphBLAS specification, 
as is common practice in computing, we refer to operators as \emph{associative} 
when their mathematical definition over infinitely precise numbers is associative 
even when they are only approximately associative when applied to finite precision 
numbers.

No GraphBLAS method will imply a predefined grouping over any associative operators. 
Implementations of the GraphBLAS are encouraged to exploit associativity to optimize 
performance of any GraphBLAS method with this requirement. This holds even if the 
definition of the GraphBLAS method implies a fixed order for the associative operations.

\glossItem{commutative operator} In an expression where a binary operator is used (usually
two or more times consecutively), that operator is \emph{commutative} if the result does 
not change regardless of the order the inputs are operated on.

No GraphBLAS method will imply a predefined ordering over any commutative operators. 
Implementations of the GraphBLAS are encouraged to exploit commutativity to optimize 
performance of any GraphBLAS method with this requirement. This holds even if the 
definition of the GraphBLAS method implies a fixed order for the commutative operations.

\glossItem{GraphBLAS operators} Binary or unary operators that act on elements of GraphBLAS 
objects.  \emph{GraphBLAS operators} are used to express algebraic structures used in the 
GraphBLAS such as monoids and semirings. They are also used as arguments to several
GraphBLAS methods. There are two types of \emph{GraphBLAS operators}: 
(1) predefined operators found in Table~\ref{Tab:PredefOperators} and (2) user-defined 
operators created using {\sf GrB\_UnaryOp\_new()} or {\sf GrB\_BinaryOp\_new()} 
(see Section~\ref{Sec:AlgebraMethods}).

\glossItem{monoid} An algebraic structure consisting of one domain, an associative 
binary operator, and the identity of that operator.  There are two types 
of GraphBLAS monoids: (1) predefined monoids found in 
Table~\ref{Tab:PredefinedMonoids} and (2) user-defined monoids created using 
{\sf GrB\_Monoid\_new()} (see Section~\ref{Sec:AlgebraMethods}). 

\glossItem{semiring} An algebraic structure consisting of a set of allowed values
(the \emph{domain}), a commutative and associative binary operator called addition, a binary operator 
called multiplication (where multiplication distributes over addition),
and identities over addition (\emph{0}) and multiplication (\emph{1}).  The additive
identity is an annihilator over multiplication.   

\glossItem{GraphBLAS semiring} is allowed to diverge from the mathematically 
rigorous definition of a \emph{semiring} since certain combinations of domains, operators, and identity 
elements are useful in graph algorithms even when they do not strictly match the mathematical
definition of a semiring.
There are two types 
of \emph{GraphBLAS semirings}: (1) predefined semirings found in 
Tables~\ref{Tab:PredefinedTrueSemirings} and~\ref{Tab:PredefinedUsefulSemirings}, and (2) user-defined semirings created using 
{\sf GrB\_Semiring\_new()} (see Section~\ref{Sec:AlgebraMethods}).

\glossItem{index unary operator} A variation of the unary operator that operates
on elements of GraphBLAS vectors and matrices along with the index values 
representing their location in the objects.  There are predefined index unary
operators found in Table~\ref{Tab:PredefIndexOperators}), and user-defined
operators created using {\sf GrB\_IndexUnaryOp\_new} (see Section~\ref{Sec:AlgebraMethods}).
\glossEnd

%=============================================================================

\subsection{The execution of an application using the GraphBLAS C API}

\glossBegin
\glossItem{program order} The order of the GraphBLAS method calls in a
thread, as defined by the text of the program.

\glossItem{host programming environment} The GraphBLAS specification defines an API.  
The functions from the API appear in a program.  This program is written using a programming language
and execution environment defined outside of the GraphBLAS.  We refer to this programming environment
as the ``host programming environment''.

\glossItem{execution time} time expended while executing instructions defined by a program.
This term is specifically used in this specification in the context of computations 
carried out on behalf of a call to a GraphBLAS method.

%% The original definition was too narrow by only referencing GraphBLAS methods.
%% Also, I didn't see the reason why the comment about execution time was retrieved was included.
%\glossItem{execution time} The time it takes to execute a GraphBLAS
%method call. Implementations are free, but not mandated, to specify how
%the execution time of a method call can be retrieved.

\glossItem{sequence} A GraphBLAS application uniquely defines a directed
acyclic graph (DAG) of GraphBLAS method calls based on their program order.  
At any point in a program, the state of any GraphBLAS object is defined by a 
subgraph of that DAG.  An ordered collection of GraphBLAS method calls in program order that
defines that subgraph for a particular object is the \emph{sequence} for that object.

\glossItem{complete}  A GraphBLAS object is complete when it can be used in a happens-before relationship
with a method call that reads the variable on another thread.  This concept is used
when reasoning about memory orders in multithreaded programs.  A GraphBLAS object defined on one thread 
that is complete can be safely used as an {\sf IN} or {\sf INOUT} argument
in a method-call on a second thread assuming the method calls are correctly synchronized so the definition on 
the first thread \emph{happens-before} it is used on the second thread.  In blocking-mode, an object is 
complete after a GraphBLAS method call that writes to that object returns.   In nonblocking-mode, an object is complete 
after a call to the {\sf GrB\_wait()} method with the {\sf GrB\_COMPLETE} parameter.

\glossItem{materialize} A GraphBLAS object is materialized when it is (1) complete, (2) the computations 
defined by the sequence that define the object have finished (either fully or stopped at an error) and will not consume any 
additional computational resources, and (3) any errors associated with that sequence are available to be read according to the 
GraphBLAS error model.  A GraphBLAS object that is never loaded into a non-opaque data structure may 
potentially never be materialized.  This might happen, for example, if the operations 
associated with the object are fused or otherwise changed by the runtime system 
that supports the implementation of the GraphBLAS C API.   An object can be materialized by a call
to the materialize mode of the {\sf GrB\_wait()} method. 

\glossItem{context}  An instance of the GraphBLAS C API implementation
as seen by an application.  An application can have only one context between the 
start and end of the application.  
A context begins with the first thread that calls {\sf GrB\_init()} and ends with the 
first thread to call {\sf GrB\_finalize()}.  
It is an error for {\sf GrB\_init()} or {\sf GrB\_finalize()} to be called more than one
time within an application.  The context is used to constrain the behavior of an
instance of the GraphBLAS C API implementation and support various execution strategies.
Currently, the only
supported constraints on a context pertain to the mode of program execution.

\glossItem{program execution mode} Defines how a GraphBLAS sequence executes, and is associated 
with the {\it context} of a GraphBLAS C API implementation. It is set by an 
application with its call to {\sf GrB\_init()} to one of two possible states.  
In \emph{blocking mode}, GraphBLAS methods return after the computations 
complete and any output objects have been materialized.  In {\it nonblocking mode}, a 
method may return once the arguments are tested as consistent with 
the method (\ie, there are no API errors), and potentially before any computation 
has taken place.
\glossEnd

%=============================================================================

\subsection{GraphBLAS methods: behaviors and error conditions}
\glossBegin
\glossItem{implementation-defined behavior} Behavior that must be documented
by the implementation and is allowed to vary among different
compliant implementations. 

\glossItem{undefined behavior} Behavior that is not specified by the GraphBLAS C API.
A conforming implementation is free to choose results delivered from a method
whose behavior is undefined. 

\glossItem{thread-safe}  Consider a function called from multiple threads with 
arguments that do not overlap in memory (i.e. the argument lists do not share 
memory).  If the function is \emph{thread-safe} then it will behave the same 
when executed concurrently by multiple threads or sequentially on a single 
thread.

\glossItem{dimension compatible} GraphBLAS objects (matrices and vectors) that are
passed as parameters to a GraphBLAS method are dimension (or shape) compatible if
they have the correct number of dimensions and sizes for each dimension to satisfy 
the rules of the mathematical definition of the operation associated with the method. 
If any \emph{dimension compatibility} rule above is violated, execution of the GraphBLAS 
method ends and the {\sf GrB\_DIMENSION\_MISMATCH} error is returned.

\glossItem{domain compatible} Two domains for which values from one domain can be 
cast to values in the other domain as per the rules of the C language. In particular, 
domains from Table~\ref{Tab:PredefinedTypes} 
are all compatible with each other, and a domain from a user-defined type is only 
compatible with itself. If any \emph{domain compatibility} rule above is 
violated, execution of the GraphBLAS method ends and the {\sf GrB\_DOMAIN\_MISMATCH} 
error is returned.
\glossEnd

\vfill

\newgeometry{left=2.5cm,top=2cm,bottom=2cm}

%=============================================================================
%=============================================================================

\section{Notation}

\begin{tabular}[H]{l|p{5in}}
Notation & Description \\
\hline
$\Dout, \Dinn, \Din1, \Din2$  & Refers to output and input domains of various GraphBLAS operators. \\
$\bDout(*), \bDinn(*),$ & Evaluates to output and input domains of GraphBLAS operators (usually \\
~~~~$\bDin1(*), \bDin2(*)$ & a unary or binary operator, or semiring). \\
$\mathbf{D}(*)$   & Evaluates to the (only) domain of a GraphBLAS object (usually a monoid, vector, or matrix). \\ 
$f$             & An arbitrary unary function, usually a component of a unary operator. \\
$\mathbf{f}(F_u)$ & Evaluates to the unary function contained in the unary operator given as the argument. \\
$\odot$         & An arbitrary binary function, usually a component of a binary operator. \\
$\mathbf{\bigodot}(*)$ & Evaluates to the binary function contained in the binary operator or monoid given as the argument. \\
$\otimes$       & Multiplicative binary operator of a semiring. \\
$\oplus$        & Additive binary operator of a semiring. \\
$\mathbf{\bigotimes}(S)$ & Evaluates to the multiplicative binary operator of the semiring given as the argument. \\
$\mathbf{\bigoplus}(S)$ & Evaluates to the additive binary operator of the semiring given as the argument. \\
$\mathbf{0}(*)$   & The identity of a monoid, or the additive identity of a GraphBLAS semiring. \\
$\mathbf{L}(*)$   & The contents (all stored values) of the vector or matrix GraphBLAS objects.  For a vector, it is the set of (index, value) pairs, and for a matrix it is the set of (row, col, value) triples. \\
$\mathbf{v}(i)$ or $v_i$   & The $i^{th}$ element of the vector $\vector{v}$.\\
$\mathbf{size}(\vector{v})$ & The size of the vector $\vector{v}$.\\
$\mathbf{ind}(\vector{v})$ & The set of indices corresponding to the stored values of the vector $\vector{v}$.\\
$\mathbf{nrows}(\vector{A})$ & The number of rows in the $\matrix{A}$.\\
$\mathbf{ncols}(\vector{A})$ & The number of columns in the $\matrix{A}$.\\
$\mathbf{indrow}(\vector{A})$ & The set of row indices corresponding to rows in $\matrix{A}$ that have stored values.  \\
$\mathbf{indcol}(\vector{A})$ & The set of column indices corresponding to columns in $\matrix{A}$ that have stored values. \\
$\mathbf{ind}(\vector{A})$ & The set of $(i,j)$ indices corresponding to the stored values of the matrix. \\
$\mathbf{A}(i,j)$ or $A_{ij}$ & The element of $\matrix{A}$ with row index $i$ and column index $j$.\\
$\matrix{A}(:,j)$ & The $j^{th}$ column of matrix $\matrix{A}$.\\
$\matrix{A}(i,:)$ & The $i^{th}$ row of matrix $\matrix{A}$.\\
$\matrix{A}^T$ &The transpose of matrix $\matrix{A}$. \\
$\neg\matrix{M}$ & The complement of $\matrix{M}$.\\
s$(\matrix{M})$ & The structure of $\matrix{M}$.\\
$\vector{\widetilde{t}}$ & A temporary object created  by the GraphBLAS implementation. \\
$<type>$ & A method argument type that is {\sf void *} or one of the types from Table~\ref{Tab:PredefinedTypes}. \\
{\sf GrB\_ALL} & A method argument literal to indicate that all indices of an input array should be used.\\
{\sf GrB\_Type} & A method argument type that is either a user defined type or one of the  types from Table~\ref{Tab:PredefinedTypes}.\\
{\sf GrB\_Object} &  A method argument type referencing any of the GraphBLAS object types.\\
{\sf GrB\_NULL} & The GraphBLAS NULL.
\end{tabular}

\restoregeometry


\section{Mathematical foundations}

Graphs can be represented in terms of matrices. The values stored in these 
matrices correspond to attributes (often weights) of edges in the graph.\footnote{More information on the mathematical foundations can be found in the following paper: J. Kepner, P. Aaltonen, D. Bader,  A. Buluç, F. Franchetti, J. Gilbert, D. Hutchison, M. Kumar, A. Lumsdaine, H. Meyerhenke, S. McMillan, J. Moreira, J. Owens, C. Yang, M. Zalewski, and T. Mattson. 2016, September. Mathematical foundations of the GraphBLAS. In \emph{2016 IEEE High Performance Extreme Computing Conference (HPEC)} (pp. 1-9). IEEE.} 
Likewise, information about vertices in a graph are stored in vectors.
The set of valid values that can be stored in either matrices or vectors
is referred to as their domain. Matrices are usually sparse because the 
lack of an edge between two vertices means that nothing is stored at the 
corresponding location in the matrix.  Vectors may be sparse or dense, or they may 
start out sparse and become dense as algorithms traverse the graphs.

Operations defined by the GraphBLAS C API specification operate on these 
matrices and vectors to carry out graph algorithms.  These GraphBLAS 
operations are defined in terms of GraphBLAS semiring algebraic 
structures. Modifying the underlying semiring changes the result of 
an operation to support a wide range of graph algorithms.
Inside a given algorithm, it is often beneficial to change the GraphBLAS 
semiring that applies to an operation on a matrix.  This has two 
implications for the C binding of the GraphBLAS API.  

First, it means that we define a separate object for the semiring 
to pass into methods.  Since in many cases the full
semiring is not required, we also support passing monoids or
even binary operators, which means the semiring is implied rather than 
explicitly stated.

Second, the ability to change semirings impacts the meaning of 
the \emph{implied zero} in a sparse representation of a matrix or vector.
This element in real arithmetic is zero, which is the 
identity of the \emph{addition} operator and the annihilator of the
\emph{multiplication} operator.  As the semiring changes, this 
implied zero changes to the identity of the \emph{addition} operator 
and the annihilator (if present) of the \emph{multiplication} operator 
for the new semiring. Nothing changes regarding what is stored in the sparse 
matrix or vector, but the implied zeros within them change with respect to a 
particular operation. In all cases, the nature of the implied zero does not 
matter since the GraphBLAS C API requires that implementations treat them as 
nonexistent elements of the matrix or vector.

As with matrices and vectors, GraphBLAS semirings have domains
associated with their inputs and outputs.  The semirings in the 
GraphBLAS C API are defined with two domains associated with the input operands and one 
domain associated with output.  When used in the GraphBLAS C API these
domains may not match the domains of the matrices and vectors supplied in
the operations.  In this case, only valid \emph{domain compatible} casting 
is supported by the API.

The mathematical formalism for graph operations in the language of 
linear algebra often assumes that we can operate in the field of real numbers. 
However, the GraphBLAS C binding is designed for implementation on computers, 
which by necessity have a finite number of bits to represent numbers. 
Therefore, we require a conforming implementation to use floating point 
numbers such as those defined by the IEEE-754 standard (both single- and double-precision) 
wherever real numbers need to be represented. The practical implications of 
these finite precision numbers is that the result of a sequence of 
computations may vary from one execution to the next as the grouping of operands
(because of associativity) within the operations changes.  While techniques are known to 
reduce these effects, we do not require or even expect an implementation 
to use them as they may add considerable overhead. In most 
cases, these roundoff errors are not significant. When they are significant, 
the problem itself is ill-conditioned and needs to be reformulated.


\section{GraphBLAS opaque objects}

Objects defined in the GraphBLAS standard include types (the domains of 
elements), collections of elements (matrices, vectors, and scalars), operators 
on those elements (unary, index unary, and binary operators), algebraic 
structures (semirings and monoids), and descriptors.   GraphBLAS objects are 
defined as opaque types; that is, they are managed, manipulated, and accessed 
solely through the GraphBLAS application programming interface. This gives an 
implementation of the GraphBLAS C specification flexibility to optimize objects 
for different scenarios or to meet the needs of different hardware platforms.

A GraphBLAS opaque object is accessed through its \emph{handle}.  A handle is 
a variable that references an instance of one of the types from 
Table~\ref{Tab:ObjTypes}.  An implementation of the GraphBLAS specification 
has a great deal of flexibility in how these handles are implemented.  All 
that is required is that the handle corresponds to a type defined in the 
C language that supports assignment and comparison for equality.  The
GraphBLAS specification defines a literal {\sf GrB\_INVALID\_HANDLE} that is 
valid for each type.  Using the logical equality operator from C, it must be 
possible to compare a handle to {\sf GrB\_INVALID\_HANDLE} to verify that a 
handle is valid.


\begin{table}
\hrule
\begin{center}
\caption{Types of GraphBLAS opaque objects.}
\label{Tab:ObjTypes}
~\\
\begin{tabular}{l|l}
{\sf GrB\_Object types} & Description \\
\hline
{\sf GrB\_Type}           & Scalar type.     \\ \hline
{\sf GrB\_UnaryOp}        & Unary operator.     \\
{\sf GrB\_IndexUnaryOp}   & Unary operator, that operates on a single value and its location index values.     \\
{\sf GrB\_BinaryOp}       & Binary operator.     \\
{\sf GrB\_Monoid}         & Monoid algebraic structure.     \\
{\sf GrB\_Semiring}       & A GraphBLAS semiring algebraic structure. \\ \hline
{\sf GrB\_Scalar}         & One element; could be empty. \\ 
{\sf GrB\_Vector}         & One-dimensional collection of elements; can be sparse.     \\
{\sf GrB\_Matrix}         & Two-dimensional collection of elements; typically sparse.    \\ \hline
{\sf GrB\_Descriptor}     & Descriptor object, used to modify behavior of methods (specifically \\
                          & GraphBLAS operations).     \\
\end{tabular}
\end{center}
\hrule
\end{table}

Every GraphBLAS object has a \emph{lifetime}, which consists of
the sequence of instructions executed in program order between the
\emph{creation} and the \emph{destruction} of the object.  The GraphBLAS C
API predefines a number of these objects which are created
when the GraphBLAS context is initialized by a call to {\sf GrB\_init}
and are destroyed when the GraphBLAS context is terminated by a call to
{\sf GrB\_finalize}.

An application using the GraphBLAS API can create additional objects by
declaring variables of the appropriate type from Table~\ref{Tab:ObjTypes} for 
the objects it will use.  Before use, the object must be initialized 
with a call call to one of the object's respective \emph{constructor} methods.  
Each kind of object has at least one explicit constructor method of the form 
{\sf GrB\_*\_new} where `{\sf *}' is replaced with the type of object (e.g., 
{\sf GrB\_Semiring\_new}). Note that some objects, especially collections, 
have additional constructor methods such as duplication, import, or 
deserialization.  Objects explicitly created by a call to a constructor 
should be destroyed by a call to {\sf GrB\_free}. The behavior of a program
that calls {\sf GrB\_free} on a pre-defined object is undefined.

%This is typically done with one of 
%the methods that has a ``{\sf \_new}'' suffix in its name (e.g., 
%{\sf GrB\_Vector\_new}).  If available, an object can also be initialized by 
%duplicating an existing object with one of the methods that has the 
%``{\sf \_dup}'' suffix in its name  (e.g., {\sf GrB\_Vector\_dup}).  Note that 
%there are other valid constructor methods included in the API (e.g., 
%``{\sf \_diag}'', ``{\sf \_import}'', and ``{\sf \_deserialize}'' matrix 
%methods).  Regardless of the method of construction, any resources associated 
%with that object can be released (destructed) by a call to the {\sf GrB\_free} 
%method when an application is finished with an object.    

These constructor and destructor methods are the only methods that change 
the value of a handle.  Hence, objects changed by these methods are passed
into the method as pointers.  In all other cases, handles are not changed by the 
method and are passed by value.  For example, even when multiplying matrices, 
while the contents of the output product matrix changes, the handle for that 
matrix is unchanged. 

Several GraphBLAS constructor methods take other objects as input arguments
and use these objects to create a new object. For all these
methods, the lifetime of the created object must end strictly before
the lifetime of any dependent input objects. For example, a vector constructor
{\sf GrB\_Vector\_new} takes a {\sf GrB\_Type} object as input. That type
object must not be destroyed until after the created vector is destroyed.
Similarly, a {\sf GrB\_Semiring\_new} method takes a monoid and
a binary operator as inputs. Neither of these can be destroyed until
after the created semiring is destroyed.

Note that some constructor methods like {\sf GrB\_Vector\_dup} and 
{\sf GrB\_Matrix\_dup} behave differently. In these cases, the input 
vector or matrix can
be destroyed as soon as the call returns. However, the original type
object used to create the input vector or matrix cannot be destroyed
until after the vector or matrix created by {\sf GrB\_Vector\_dup} or
{\sf GrB\_Matrix\_dup} is destroyed.  This behavior must hold for any
chain of duplicating constructors.

Programmers using GraphBLAS handles must be careful to distinguish between a 
handle and the object manipulated through a handle.  For example, a program may 
declare two GraphBLAS objects of the same type, initialize one, and then assign 
it to the other variable.  That assignment, however, only assigns the handle to 
the variable.  It does not create a copy of that variable (to do that, one 
would need to use the appropriate duplication method).  If later the object is 
freed by calling {\sf GrB\_free} with the first variable, the object is 
destroyed and the second variable is left referencing an object that no longer 
exists (a so-called ``dangling handle'').

In addition to opaque objects manipulated through handles, the GraphBLAS C API 
defines an additional opaque object as an internal object; that is, the object 
is never exposed as a variable within an application.  This opaque object is 
the mask used to control which computed values can be stored in the output 
operand of a \emph{GraphBLAS operation}.  Masks are described in 
Section~\ref{Sec:Masks}.

% ========================================================================

\section{Execution model}
\label{Sec:ExecutionModel}

A program using the GraphBLAS C API is called
a GraphBLAS application.  The application constructs GraphBLAS objects,
manipulates them to implement a graph algorithm, and then extracts
values from the GraphBLAS objects to produce the results for that algorithm. 
Functions defined within the GraphBLAS C API that manipulate GraphBLAS
objects are called \emph{methods}.  If the method corresponds to one
of the operations defined in the GraphBLAS mathematical specification,
we refer to the method as an \emph{operation}.

The GraphBLAS application specifies an ordered collection of 
GraphBLAS method calls defined by the order
they appear in the text of the program (the \emph{program order}).  
These define a directed acyclic graph (DAG) where nodes are GraphBLAS
method calls and edges are dependencies between method calls.  

Each method call in the DAG uniquely and unambiguously defines the output
GraphBLAS objects as long as there are no execution errors that
put objects in an invalid state (see Section~\ref{Sec:ErrorModel}).
An ordered collection of method calls, a subgraph of the overall DAG for an 
application, defines the state of a GraphBLAS object at any point in a program.  
This ordered collection is the \emph{sequence} for that object.  

Since the GraphBLAS execution is defined in terms of a DAG and the 
GraphBLAS objects are opaque, the semantics of the GraphBLAS specification
affords an implementation considerable flexibility to optimize performance.  A 
GraphBLAS implementation can defer execution of nodes in the DAG, fuse nodes, or 
even replace whole subgraphs within the DAG to optimize performance.  We discuss 
this topic further in section~\ref{Sec:Modes} when we describe 
\emph{blocking} and \emph{non-blocking} execution modes.

A correct GraphBLAS application must be \emph{race-free}.  This means that the 
DAG produced by an application and the results produced by execution of that 
DAG must be the same regardless of how the threads are scheduled for execution.  
It is the application programmer's 
responsibility to control memory orders and establish the required synchronized-with
relationships to assure race-free execution of a multi-threaded GraphBLAS 
application.  Writing race-free GraphBLAS applications is discussed further in 
Section~\ref{Sec:MultiThread}.

\subsection{Execution modes}
\label{Sec:Modes}

The execution of the DAG defined by a GraphBLAS application depends on the
\emph{execution mode} of the GraphBLAS program.  There are two modes:
\emph{blocking} and \emph{nonblocking}.

\begin{itemize}
\item \emph{blocking}: In blocking mode, each method finishes the
GraphBLAS operation defined by the method and all output GraphBLAS
objects are \emph{materialized} before proceeding to the
next statement.  Even mechanisms that break the opaqueness of the
GraphBLAS objects (\eg, performance monitors, debuggers, memory dumps)
will observe that the operation has finished.

\item \emph{nonblocking}: In nonblocking mode, each method may return
once the input arguments have been inspected and verified to define
a well formed GraphBLAS operation. (That is, there are no API errors;
see Section~\ref{Sec:ErrorModel}.) The GraphBLAS method may not have
finished, but the output object is ready to be used by the next GraphBLAS
method call.  If needed, a call to {\sf GrB\_wait} with {\sf GrB\_COMPLETE} or 
{\sf GrB\_MATERIALIZE} can be used to force the sequence for a GraphBLAS 
object ({\sf obj}) to finish its execution.
\end{itemize}

The \emph{execution mode} is defined in the GraphBLAS C API when the context of 
the library invocation is defined.  This occurs once before any GraphBLAS
methods are called with a call to the {\sf GrB\_init()} function.
This function takes a single argument of type {\sf GrB\_Mode} with values
shown in Table~\ref{Tab:EnumerationModes}(a).

An application executing in nonblocking mode is not required to return
immediately after input arguments have been verified. A conforming
implementation of the GraphBLAS C API running in nonblocking mode may
choose to execute {\it as if} in blocking mode.  A sequence of operations
in nonblocking mode where every GraphBLAS operation with output object
{\sf obj} is followed by a {\sf GrB\_wait(obj, GrB\_MATERIALIZE)} call is 
equivalent to the same sequence in blocking mode with {\sf GrB\_wait(obj, 
GrB\_MATERIALIZE)} calls removed.

Nonblocking mode allows for any execution strategy that satisfies the
mathematical definition of the sequence.  The methods can be placed
into a queue and deferred.  They can be chained together and fused
(\eg, replacing a chained pair of matrix products with a matrix triple
product).  Lazy evaluation, greedy evaluation, and asynchronous execution
are all valid as long as the final result agrees with the mathematical
definition provided by the sequence of GraphBLAS method calls appearing
in  program order.

Blocking mode forces an implementation to carry out precisely the
GraphBLAS operations defined by the methods and to complete each and
every method call individually.  It is valuable for debugging or in
cases where an external tool such as a debugger needs to evaluate the
state of memory during a sequence of operations.

In a sequence of operations free of execution errors, and with input
objects that are well-conditioned, the results from blocking and
nonblocking modes should be identical outside of effects due to roundoff
errors associated with floating point arithmetic.  Due to the great
flexibility afforded to an implementation when using nonblocking mode,
we expect execution of a sequence in nonblocking mode to potentially
complete execution in less time.

It is important to note that, processing of nonopaque objects is never deferred in
GraphBLAS. That is, methods that consume nonopaque objects (\eg, {\sf
GrB\_Matrix\_build()}, Section~\ref{Sec:Matrix_build}) and methods that
produce nonopaque objects (\eg, {\sf GrB\_Matrix\_extractTuples()},
Section~\ref{Sec:Matrix_extractTuples}) always finish consuming or
producing those nonopaque objects before returning regardless of the 
execution mode.

Finally, after all GraphBLAS method calls have been made, the context is terminated
with a call to {\sf GrB\_finalize()}.  In the current version of the
GraphBLAS C API, the context can be set only once in the execution of
a program. That is, after {\sf GrB\_finalize()} is called, a subsequent
call to {\sf GrB\_init()} is not allowed.

%\vfill

%============================================================================
\subsection{Multi-threaded execution}
\label{Sec:MultiThread}

The GraphBLAS C API is designed to work with applications that
utilize multiple threads executing within a shared address space.
This specification does not define how threads are created, managed and
synchronized.  We expect the host programming environment to provide
those services. 

A conformant implementation of the GraphBLAS must be \emph{thread safe}.  A 
GraphBLAS library is thread safe when independent method calls (i.e., GraphBLAS 
objects are not shared between method calls) from multiple threads in a race-free 
program return the same results as would follow from their sequential execution 
in some interleaved order.   This is a common requirement in software libraries. 

Thread safety applies to the behavior of multiple independent threads.  In the 
more general case for multithreading, threads are not independent; they share 
variables and mix read and write operations to those variables across threads.  
A memory consistency model defines which values can be returned when reading an 
object shared between two or more threads.  The GraphBLAS specification does not 
define its own memory consistency model. Instead the specification defines what 
must be done by a programmer calling GraphBLAS methods and by the implementor of 
a GraphBLAS library so an implementation of the GraphBLAS specification can work 
correctly with the memory consistency model for the host environment. 

A memory consistency model is defined in terms of happens-before relations between 
methods in different threads.  The defining case is a method that writes to an 
object on one thread that is read (i.e., used as an IN or INOUT argument) in a 
GraphBLAS method on a different thread.  The following steps must occur 
between the different threads.
\begin{itemize}
\item A sequence of GraphBLAS methods results in the definition of the GraphBLAS object.
\item The GraphBLAS object is put into a state of completion by a call to {\sf GrB\_wait()} 
with the {\sf GrB\_COMPLETE} parameter (see Table~\ref{Tab:EnumerationModes}(b)).  
A GraphBLAS object is said to be \emph{complete} when it can be safely used as an 
{\sf IN} or {\sf INOUT} argument in a GraphBLAS method call from a different thread. 
\item Completion happens before a synchronized-with relation that executes 
with \emph{at least} a release memory order.
\item A synchronized-with relation on the other thread executes with \emph{at 
least} an acquire memory order.
\item This synchronized-with relation happens-before the GraphBLAS method that 
reads the graphBLAS object.
\end{itemize}
We use the phrase \emph{at least} when talking about the memory orders to 
indicate that a stronger memory order such as \emph{sequential consistency} can 
be used in place of the acquire-release order.

A program that violates these rules contains a data race. That is, its reads and writes are 
unordered across threads making the final value of a variable undefined.  A program that 
contains a data race is invalid and the results of that program are undefined.  
We note that multi-threaded execution is compatible with both blocking and non-blocking
modes of execution. 

Completion is the central concept that allows GraphBLAS objects to be used in happens-before
relations between threads.  In earlier versions of GraphBLAS (1.X) completion was implied
by any operation that produced non-opaque values from a GraphBLAS object.  These 
operations are summarized in  Table~\ref{Tab:ExtractMethods}).  In GraphBLAS 2.0, these 
methods no longer imply completion.  This change was made since there are cases where 
the non-opaque value is needed but the object from which it is computed is not. We
want implementations of the GraphBLAS to be able to exploit this case and not form the 
opaque object when that object is not needed.  

\begin{table}[tbh]
    \hrule
    \begin{center}
        \caption[Methods that forced completion prior to GraphBLAS v2.0.]{Methods that extract values from a GraphBLAS object  
        forced completion of the operations contributing to that particular object in GraphBLAS 1.X. 
        In GraphBLAS 2.X, these methods \emph{do not} force completion.}
        \label{Tab:ExtractMethods}

        \begin{tabular}{l|l}
            Method    					& Section 				\\ \hline

            {\sf GrB\_Vector\_nvals}        		& \ref{Sec:Vector_nvals}        	\\
            {\sf GrB\_Vector\_extractElement}     	& \ref{Sec:extract_single_element_vec}  \\
            {\sf GrB\_Vector\_extractTuples}    	& \ref{Sec:Vector_extractTuples}    	\\
            {\sf GrB\_Matrix\_nvals}        		& \ref{Sec:Matrix_nvals}        	\\
            {\sf GrB\_Matrix\_extractElement}     	& \ref{Sec:extract_single_element_mat}  \\
            {\sf GrB\_Matrix\_extractTuples}    	& \ref{Sec:Matrix_extractTuples}    	\\
            {\sf GrB\_reduce} (vector-scalar value variant)   & \ref{Sec:Reduce_vector_scalar}        \\
            {\sf GrB\_reduce} (matrix-scalar value variant)   & \ref{Sec:Reduce_matrix_scalar}        \\
        \end{tabular}
    \end{center}
    \hrule
\end{table}




%============================================================================
\section{Error model}
\label{Sec:ErrorModel}

All GraphBLAS methods return a value of type {\sf GrB\_Info} (an enum) to 
provide information available to the system at the time the method returns. 
The returned value will be one of the defined values shown in 
Table~\ref{Tab:GrBInfoValues}. The return values fall into three groups: 
informational, API errors, and execution errors.  While API and execution 
errors take on negative values, informational return values listed in  
Table~\ref{Tab:GrBInfoValues}(a) are non-negative and include 
{\sf GrB\_SUCCESS} (a value of 0) and {\sf GrB\_NO\_VALUE}.  

An API error (listed in Table~\ref{Tab:GrBInfoValues}(b)) means that a GraphBLAS 
method was called with parameters
that violate the rules for that method.  These errors are restricted
to those that can be determined by inspecting the dimensions and domains of
GraphBLAS objects, GraphBLAS operators, or the values of scalar parameters
fixed at the time a method is called.  API errors are deterministic and
consistent across platforms and implementations.  API errors are never
deferred, even in nonblocking mode. That is, if a method is called in
a manner that would generate an API error, it always returns with the
appropriate API error value.  If a GraphBLAS method returns with an
API error, it is guaranteed that none of the arguments to the method
(or any other program data) have been modified.  The informational return
value, {\sf GrB\_NO\_VALUE}, is also deterministic and never deferred in 
nonblocking mode.

Execution errors (listed in Table~\ref{Tab:GrBInfoValues}(c)) indicate that 
something went wrong during the execution
of a legal GraphBLAS method invocation.  Their occurrence may depend on
specifics of the execution environment and data values being manipulated.
This does not mean that execution errors are the fault of the GraphBLAS
implementation.  For example, a memory leak could arise from an error in
an application's source code (a ``program error''), but it may manifest
itself in different points of a program's execution (or not at all)
depending on the platform, problem size, or what else is running at
that time.  Index out-of-bounds errors, for example, always indicate a
program error.

If a GraphBLAS method returns with any execution error other than 
{\sf GrB\_PANIC}, it is guaranteed that the state of any argument used as 
input-only is unmodified.  Output arguments may be left in an invalid state, 
and their use downstream in the program flow may cause additional errors.  If a 
GraphBLAS method returns with a {\sf GrB\_PANIC} execution error, no guarantees 
can be made about the state of any program data. 

In nonblocking mode, execution errors can be deferred.  A return value
of {\sf GrB\_SUCCESS} only guarantees that there are no API errors
in the method invocation.  If an execution error value is returned
by a method with output object {\sf obj} in nonblocking mode, it
indicates that an error was found during execution of any of the pending
operations on {\sf obj}, up to and including the {\sf GrB\_wait()} method
(Section~\ref{Sec:GrB_wait}) call that completes those pending operations.
When possible, that return value will provide information concerning
the cause of the error.

As discussed in Section~\ref{Sec:GrB_wait}, a {\sf GrB\_wait(obj)} on a
specific GraphBLAS object {\sf obj} completes all pending operations on
that object.  No additional errors on the methods that precede the call
to {\sf GrB\_wait} and have {\sf obj} as an {\sf OUT} or {\sf INOUT}
argument can be reported.  From a GraphBLAS perspective, those methods
are {\em complete}.  Details on the guaranteed state of objects after
a call to {\sf GrB\_wait} can be found in Section~\ref{Sec:GrB_wait}.

After a call to any GraphBLAS method that modifies an opaque object, the 
program can retrieve additional error information (beyond the error code 
returned by the method) though a call to the function {\sf GrB\_error()}, 
passing the method's output object as 
described in Section~\ref{Sec:GrB_error}.  The function returns a
pointer to a NULL-terminated string, and the contents of that string
are implementation-dependent. In particular, a null string (not a {\sf
NULL} pointer) is always a valid error string.  {\sf GrB\_error()} is
a thread-safe function, in the sense that multiple threads can call it
simultaneously and each will get its own error string back, referring
to the object passed as an input argument.
