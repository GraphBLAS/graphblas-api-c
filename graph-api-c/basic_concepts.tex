\chapter{Basic concepts}

The GraphBLAS C API is used to construct  
graph algorithms expressed ``in the language of linear algebra''
%\cite{KepGil2011}.
Graphs are expressed as matrices and the operations over 
these matrices are generalized through the use of a
semiring algebraic structure.

In this chapter, we will define the basic concepts used to
define the GraphBLAS C API.  This includes the following elements:
\begin{itemize}
\item Glossary of terms used in this document.  

\item Algebraic structures and associated arithmetic foundations of the API.

\item Domains of  elements in the GraphBLAS.  

\item Functions that appear in the GraphBLAS algebraic 
structures and how they are managed.

\item Indices, index arrays and scalar arrays used
to expose the contents of GraphBLAS objects.  

\item The execution and error models implied by the GraphBLAS C specification.

\end{itemize}

\section{Glossary}

%
%  My nice glossary macros didn't work here.  I don't know why.
%  For now, I'll just do this as an itemized list.
%
\glossBegin

\glossItem{application} A program that calls methods from the GraphBLAS C API to
solve a problem.

\glossItem{context} The GraphBLAS C API was designed with the expectation that
implementations of the API might utilize sophisticated execution strategies 
to optimize performance.   We anticipate that an application may need 
to apply constraints on the behavior of implementations of the 
GraphBAS C API and that these constraints may vary from one application 
to another.   To the application, it appears as if the application 
interacts with a distinct instance of the GraphBLAS C API implementation.
The state of this instance is called the GraphBLAS \emph{context}. 
The context  is set with {\tt GrB\_init()}. Currently, the only
supported constraints on a context pertain to the mode of program execution.

\glossItem{domain} The set of valid values for the elements of a GraphBLAS object.

\glossItem{function} The term \emph{function} as used in the GraphBLAS specification
refers to a named group of statements in the C programming language.  Methods, operators,
and user-defined functions are typically implemented as C functions and when referring to 
the code programmers write as opposed to their role as an element of the GraphBLAS, they may
be referred to as such.

\glossItem{GraphBLAS operators} Binary or unary functions that act on elements of GraphBLAS objects.  \emph{GraphBLAS operators} are used to express algebraic structures used in the GraphBLAS such as monoids and semirings. \emph{GraphBLAS operators} come in two types: (1) predefined operators found in Table~\ref{Tab:PredefinedOperators} and (2) user-defined operators using {\tt GrB\_UnaryFunction\_new()} or {\tt GrB\_BinaryFunction\_new()} (see Section~\ref{Sec:AlgebraMethods}).

\glossItem{GraphBLAS object}  A instance of a data structure defined by the GraphBLAS C
API that is opaque and manipulated only through the API.  The fact the object
is based on an opaque datatype gives an implementation of the GraphBLAS C API
flexibility to optimize the structure for a particular platform.

\glossItem{GraphBLAS operation} A mathematical operation defined in the
GraphBLAS mathematical specification.  These operations  typically act
on matrices and vectors with elements defined in terms of an algebraic semiring.

\glossItem{implementation defined} Behavior that must be documented
by the implementation and is allowed to vary among different
compliant implementations. 

\glossItem{method} A C function defined in the GraphBLAS C API that manipulates
an opaque GraphBLAS object.

% Scott suggested calling this "execution mode"
\glossItem{mode} A GraphBLAS sequence executes in one of two modes.  
In \emph{blocking mode}, GraphBLAS methods return after the computations 
complete and any output objects have been updated.  In nonblocking mode, a 
method returns once the arguments are tested as consistent with 
the method but potentially before any computation has proceeded.

\glossItem{monoid} An algebraic structure consisting of a domain, an 
associative\footnote{We expect implementations of the GraphBLAS C API
to use IEEE-754 arithmetic which is not strictly associative.}
binary operation, and an identity corresponding to that 
operation.

\glossItem{non-opaque} Any datatype that exposes its internal structure.   This contrasts
with an \emph{opaque} datatype which hides its internals structure and can only
be manipulated through an API.

\glossItem{program order} The text of an application program defines an order
of the GraphBLAS methods.  This order is called the \emph{program order}.

\glossItem{semiring} An algebraic structure consisting of a set of allowed values
(the \emph{domain}), two commutative binary operators called \emph{addition} 
and \emph{multiplication} over which the distributive property holds, identities 
over addition (\emph{0}) and multiplication (\emph{1}), and finally the additive
identity is an annihilator over multiplication.   

% Scott suggested calling this "execution seqence"
\glossItem{sequence} A series of GraphBLAS method calls in program order that: (1) begins with the first GraphBLAS method that modifies a GraphBLAS object; and (2) terminates with a GraphBLAS method that explicitly waits for the sequence of methods to complete or any method that reads values from a GraphBLAS object into a non-opaque object.

\glossItem{structural zero} Also known as an \emph{implied zero}, a \emph{structural zero} is any element which has a valid index (or indices) in a GraphBLAS vector or matrix but is not explicitly identified in the list of elements of that vector or matrix. From a mathematical perspective, a \emph{structural zero} is treated as having the value of the zero element of the relevant monoid or semiring.

\glossItem{structural complement} The \emph{structural complement} of a GraphBLAS vector or matrix of any domain is another vector or matrix, of domain {\tt bool}, in which the explicitly identified elements (with a value of {\tt true}) are the \emph{structural zeroes} of the original vector or matrix (which have an implied value of {\tt false}). 

\glossItem{thread safe} A routine is said to be \emph{thread safe} if it performs its intended 
function even when executed concurrently (by more than one thread).

\glossEnd


\section{Algebraic and Arithmetic foundations}

Graphs can be represented in terms of matrices and the GraphBLAS
operate on these matrices to construct graph algorithms.
These GraphBLAS operations are defined in terms of semiring algebraic 
structures. Modifying the underlying semiring changes the result of 
an operation to support an even wider range of graph algorithms.

Inside a given algorithm, it is often beneficial to change the semiring
that applies to an operation on a matrix.  This has two 
implications on the C-binding to the GraphBLAS.  First,
it means that we define a separate object for the semiring 
that is passed into functions.  Since in many cases the full
semiring is not required, we also support passing monoids or
even functions; which basically means the semiring is implied but not 
explicitly stated.

Second, the ability to change semirings impacts the meaning of 
the \emph{implied zero} in a sparse representation of a matrix.
This element in real arithmetic is zero which is the 
identity of the \emph{addition} operator and the annihilator of
\emph{multiplication} operator.   As the semiring changes, this 
\emph{implied} or \emph{structural zero} changes to the identity of 
the \emph{addition} operator and the annihilator of the \emph{multiplication} 
operator for the new semiring.   Nothing changes in the
stored matrix, but the implied values within the sparse matrix change
with respect to a particular operation.  In most cases, the nature
of the implied zero does not matter since the GraphBLAS treats these
as elements of the matrix that do not exist.  As we will see, however,
there are a small subset of GraphBLAS functions 
(the element-wise operations) where to understand 
the function you need to understand the implied semiring.

The mathematical formalism for graph operations in the language of 
linear algebra assumes that we can operate in the field of real numbers. 
However, the GraphBLAS C binding is designed for implementation on computers 
which by necessity have a finite number of bits to represent numbers. 
Therefore, we require a conforming implementation to use floating-point 
numbers as defined by the IEEE-754 standard (both single- and double-precision) 
wherever real numbers need to be represented. The practical implications of 
these finite precision numbers is that the result of a sequence of 
computations may vary from one execution to the next as the way 
operations are associated change. While techniques are known to 
reduce these effects, we do not require or even expect an implementation 
to use them as they add considerable overhead. The fact is that in most 
cases, these roundoff errors are not significant and when they are, 
the problem itself is ill-conditioned and needs to be reformulated.

\section{Domains}

GraphBLAS defines two kinds of collections: matrices and vectors.
For any given collection, the elements of the collection belong to
a \emph{domain}, which is the set of valid values for the elements.
In GraphBLAS, domains correspond to the valid values for types from
the host language (in our case, the C programming language).  For any
variable or object $V$ in GraphBLAS we denote as $\bold{D}(V)$ the
domain of $V$; that is, the set of possible values that elements of
$V$ can take.  The predefined types and corresponding domains used in the 
GraphBLAS are shown in Table~\ref{Tab:PredefinedTypes}.  The Boolean
type is defined in {\tt stdbool.h}, the integral types are defined in
{\tt stdint.h}, and the floating-point types are native to the language
and defined by the IEEE-754 standard.
%GraphBLAS also supports user defined types. In that case, the domain is
%the set of valid values for a variable of that type.

\begin{table}
\hrule
\begin{center}
\caption{Predefined {\sf GrB\_Type} values, the corresponding C type (for scalar
parameters, and domains for GraphBLAS. 
        \scott{Consider name change from GrB\_Type to GrB\_Domain}
        \aydin{There will be a way to introduce new GraphBLAS identifiers,
        similar to MPI\_Type\_Commit, these are just predefined stuff}
        \scott{An example would be nice, 
        especially where there is not a 1-to-1 correspondence to a built-in
        type, e.g. \{0,1\}.}}
\label{Tab:PredefinedTypes}
\begin{tabular}{l|l|l}
{\sf GrB\_Type values} & C type            & domain \\
\hline
{\sf GrB\_BOOL}        & {\tt bool}        & $\{ {\tt false}, {\tt true} \}$  \\
{\sf GrB\_INT8}        & {\tt int8\_t}     & $\mathbb{Z} \cap [-2^{7},2^{7})$  \\
{\sf GrB\_UINT8}       & {\tt uint8\_t}    & $\mathbb{Z} \cap [0,2{^8})$  \\
{\sf GrB\_INT16}       & {\tt int16\_t}    & $\mathbb{Z} \cap [-2^{15},2^{15})$ \\
{\sf GrB\_UINT16}      & {\tt uint16\_t}   & $\mathbb{Z} \cap [0,2^{16})$ \\
{\sf GrB\_INT32}       & {\tt int32\_t}    & $\mathbb{Z} \cap [-2^{31},2^{31})$ \\
{\sf GrB\_UINT32}      & {\tt uint32\_t}   & $\mathbb{Z} \cap [0,2^{32})$ \\
{\sf GrB\_INT64}       & {\tt int64\_t}    & $\mathbb{Z} \cap [-2^{63},2^{63})$ \\
{\sf GrB\_UINT64}      & {\tt uint64\_t}   & $\mathbb{Z} \cap [0,2^{64})$ \\
{\sf GrB\_FLOAT}       & {\tt float}       & IEEE 754 {\sf binary32}  \\
{\sf GrB\_DOUBLE}      & {\tt double}      & IEEE 754 {\sf binary64}  \\
\end{tabular}
\end{center}
\hrule
\end{table}

\section{Operators and Associated Functions}

GraphBLAS operators act on elements of GraphBLAS objects.   A
 \emph{binary operator} is a function that maps two input
values to one output value. A \emph{unary operator} is a function that 
maps one input value to one output value. The value of the output is 
determined by the value of the input(s).  Binary operators are defined over 
two input domains and produce an output from a (possibly different) third 
domain. Unary operators are specified over one input domain and produce an 
output from a (possibly different) second domain.

Similar to GraphBLAS types having predefined types and user-defined types, GraphBLAS operators come in two types as well: (1) predefined operators found in Table~\ref{Tab:PredefinedOperators} and (2) user-defined operators using {\tt GrB\_UnaryFunction\_new()} or {\tt GrB\_BinaryFunction\_new()} (see Section~\ref{Sec:AlgebraMethods}).

\begin{table}
\hrule
\begin{center}
\caption{Predefined unary and binary operators for GraphBLAS in C.}
\label{Tab:PredefinedOperators}

\vspace{1\baselineskip}
(a) Valid suffixes and corresponding C type ($T$ in table (b)).
\vspace{1\baselineskip}

\begin{tabular}{l|l}
Suffix		& C type \\ \hline
{\sf B}		& {\tt bool} \\
{\sf I8}	& {\tt int8\_t} \\
{\sf U8}	& {\tt uint8\_t} \\
{\sf I16}	& {\tt int16\_t} \\
{\sf U16}	& {\tt uint16\_t} \\
{\sf I32}	& {\tt int32\_t} \\
{\sf U32}	& {\tt uint32\_t} \\
{\sf I64}	& {\tt int64\_t} \\
{\sf U64}	& {\tt uint64\_t} \\
{\sf F32}	& {\tt float} \\
{\sf F64}	& {\tt double} \\
\end{tabular}

\vspace{1\baselineskip}
(b) Predefined Operators.
\vspace{1\baselineskip}

\begin{tabular}{l|l|l|l|l}
Function & GraphBLAS             &                                                              & \\
type     & identifier            & Domains                                                      & Description \\ \hline
         & {\sf GrB\_NOP}        &                                                              & no operation \\
unary    & {\sf GrB\_LNOT}       & ${\tt bool} \rightarrow {\tt bool}$                          & logical inverse \\
unary    & {\sf GrB\_SCMP}       & ${\tt bool} \rightarrow {\tt bool}$                          & structural complement \\
unary    & {\sf GrB\_NEG}        & ${\tt T} \rightarrow {\tt T}$                          & arithmetic negation \\
unary    & {\sf GrB\_INV}        & ${\tt T} \rightarrow {\tt T}$                          & arithmetic inverse \\
binary   & {\sf GrB\_LAND}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$	& logical AND \\
binary   & {\sf GrB\_LOR}        & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$        & logical OR \\
binary   & {\sf GrB\_LXOR}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$        & logical XOR \\
binary   & {\sf GrB\_MIN\_$T$}   & $T \times T \rightarrow T$                                  & minimum \\
binary   & {\sf GrB\_MAX\_$T$}   & $T \times T \rightarrow T$                                  & maximum \\
binary   & {\sf GrB\_PLUS\_$T$}	 & $T \times T \rightarrow T$    				& addition \\
binary   & {\sf GrB\_MINUS\_$T$} & $T \times T \rightarrow T$    				& subtraction \\
binary   & {\sf GrB\_TIMES\_$T$} & $T \times T \rightarrow T$    				& multiplication \\
binary   & {\sf GrB\_DIV\_$T$}   & $T \times T \rightarrow T$    				& division \\
binary   & {\sf GrB\_EQ\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& equal \\
binary   & {\sf GrB\_NE\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& not equal \\
binary   & {\sf GrB\_GT\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& greater than  \\
binary   & {\sf GrB\_LT\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& less than  \\
binary   & {\sf GrB\_GE\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& greater than or equal \\
binary   & {\sf GrB\_LE\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& less than or equal \\
\end{tabular}
\end{center}
\hrule
\end{table}

\section{Indices, Index Arrays and Scalar Arrays}

In order to interface with third-party software packages, operations 
such as buildMatrix (\S~\ref{Sec:buildMatrix})
and extractTuples (\S~\ref{Sec:extractTuples}) must specify how 
the data should be laid out in  non-opaque data structures.  To 
this end we define, explicitly the types for indices and the arrays 
used by these operations.

For indices a typedef is used to give a GraphBLAS name to a concrete type. We define it as follows:

\begin{verbatim}
    typedef uint64_t GrB_Index;
\end{verbatim}

An index array is a pointer to a set of {\sf GrB\_Index} values that are 
stored in a contiguous block of memory (\ie, {\sf GrB\_Index*})

Likewise a scalar array is a pointer to a contiguous block of memory 
storing a number of scalar values as specified by the user.

\section{Execution Model}

A program using the GraphBLAS C API constructs GraphBLAS objects,
manipulates them to implement a graph algorithm, and then extracts values 
from the GraphBLAS objects as the result of the algorithm.  Functions defined
within the GraphBLAS C API that manipulate GraphBLAS objects are called
\emph{methods}.

Graph algorithms are expressed as an ordered collection of GraphBLAS method calls
defined by the order they are encountered in a program.  This is called the 
\emph{Program Order}.  Each method in the collection uniquely and unambiguously
defines the output GraphBLAS objects based on the GraphBLAS operation and the input 
GraphBLAS objects.

We define a sequence of GraphBLAS method calls, or when the meaning is clear a \emph{sequence},
as a well defined ordered collection of GraphBLAS method calls.  The initiation of a sequence
is the first method call that modifies a graphBLAS object,  The end of the sequence is either (1) the first 
GraphBLAS method that reads values from a GraphBLAS object into a non-opaque data structure
or (2) a GraphBLAS wait method.  We collectively refer to these methods as \emph{terminating methods}.
The set of operations between the initiation of a sequence and its termination mathematically define the result
of that sequence. 

\subsection{Execution modes}

A program using the GraphBLAS C API defines a collection of sequences.  The execution model
implied by these sequences depends on the mode of the GraphBLAS program.  There are
two modes: \emph{blocking} and \emph{nonblocking}.  
\begin{itemize}
\item \emph{blocking}: In blocking mode, each method in a sequence completes the GraphBLAS operation 
defined by the method before proceeding to the next statement in program order.  Output GraphBLAS
objects defined by a method are stored in memory and are available to other C functions after each
method returns.

\item \emph{nonblocking}: In nonblocking mode, each method returns once the input arguments have 
been inspected and verified to define a well formed GraphBLAS operation.  The GraphBLAS operation
and the state of any GraphBLAS objects are undefined when a method returns until the 
terminating method in the sequence returns.
\end{itemize}

Nonblocking mode allows for any execution strategy that 
satisfies the mathematical definition of the sequence.  The methods can be placed into
a queue and deferred.  They can be chained together and fused (e.g.
replacing a chained pair of matrix products with a matrix triple product).
Lazy evaluation, greedy evaluation or asynchronous execution are all
valid as long as the final result agrees with the mathematical 
definition provided by the sequence of GraphBLAS method calls
appearing in  program order.

Blocking mode forces an implementation to carry out precisely the GraphBLAS operations
defined by the methods and to store output objects to memory between method calls.  
It is valuable for debugging or in cases where an external tool such as a debugger needs to 
evaluate the state of memory during a sequence.

In a  mathematically well-defined sequence with input objects that are well-conditioned, the results
from blocking and nonblocking modes should be identical outside of effects due to round-off errors 
from IEEE-754 floating point arithmetic.   Due to the great flexibility afforded to an implementation
when using nonblocking mode, we expect execution of a sequence in nonblocking mode to potentially
complete execution in less time.

The mode is defined in the GraphBLAS C API when the context of the library invocation 
is defined.  This occurs once before any GraphBLAS methods are called with a call to the
GrB\_init() function.   After all graphBLAS methods are complete, the context is terminated
with a call to GrB\_finalize().  In the current version of the GraphBLAS C API, the context can only be 
set once in the execution of a program; i.e. After GrB\_finalize() is called a following call to
GrB\_init() is not allowed.

\subsection{Thread safety}

Implementations of the GraphBLAS C API are required to be thread safe.  Different threads 
may create GraphBLAS sequences that do not conflict and expect the results to be the 
same (within IEEE-754 roundoff errors) regardless of whether the sequences execute serially or concurrently.

Sequences that do not conflict are free of data races.  The GraphBLAS C API does not 
define synchronization constructs to order operations between concurrent sequences.  
Therefore, in order to be race-free,  two or more sequences must not read GraphBLAS 
objects that are written in the other sequences.     

\section{Error Model}

All GraphBLAS methods return a value of type {\sf GrB\_info} to provide information available to the system at 
the time the method returns.  In blocking mode, that information pertains to the full computation and 
the return values defined for each method in the specification provide information concerning 
the condition of the computation.  

In nonblocking mode, the information pertains to a consistency 
check of the arguments to the method. Any method that terminates a sequence must return 
information about the status of that sequence of method calls.  
A return value of {\sf GrB\_SUCCESS} indicates that the method returned correctly and that the sequence produced 
the result defined by the sequence of graphBLAS operations.   Other return values from the method indicate that an error 
was found during execution of the sequence.  When possible, that return value will provide information 
concerning the cause of the error.  Additional information is returned in the null terminated character string, 
{\sf err} which is always the last argument to any method that may terminate a sequence.  
 
