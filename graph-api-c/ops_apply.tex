%-----------------------------------------------------------------------------

\subsection{{\sf apply}: Apply a function to the elements of an object}
\label{Sec:Apply}

Computes the transformation of the values of the elements of a vector or a matrix 
using a unary function, or a binary function where one argument is bound to a scalar.

%-----------------------------------------------------------------------------

\subsubsection{{\sf apply}: Vector variant}
Computes the transformation of the values of the elements of a vector using a unary function.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Vector             w,
                           const GrB_Vector       mask,
                           const GrB_BinaryOp     accum,
                           const GrB_UnaryOp      op,
                           const GrB_Vector       u,
                           const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    apply operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector {\sf w}. The 
    mask dimensions must match those of the vector {\sf w}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the
    {\sf mask} vector must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf w}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf w} entries. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]	({\sf IN}) A unary operator applied to 
    each element of input vector {\sf u}.
        
    \item[{\sf u}] ({\sf IN}) The GraphBLAS vector to which the unary function
    is applied.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf mask} vector. The stored values are not examined.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).

    \item[{\sf GrB\_DIMENSION\_MISMATCH}]  {\sf mask}, {\sf w} and/or {\sf u}
    dimensions are incompatible.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various vectors are
    incompatible with the corresponding domains of the accumulation operator
    or unary function, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_apply} computes the result of applying a unary function
to the elements of a GraphBLAS vector:
${\sf w} = f({\sf u})$; or, if an optional binary accumulation 
operator ($\odot$) is provided, ${\sf w} = {\sf w} \odot f({\sf u})$.  

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to three argument vectors are used in this {\sf GrB\_apply} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),
    \bold{L}({\sf w}) = \{(i,w_i) \} \rangle$

	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),
    \bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)

	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),
    \bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The argument vectors, unary operator and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
	\item If {\sf mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

	\item $\bold{D}({\sf w})$ must be 
    compatible with $\bDout({\sf op})$ of the unary operator.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator and 
    $\bDout({\sf op})$ of the unary operator must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.

	\item $\bold{D}({\sf u})$ must be compatible with $\bDinn({\sf op})$.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends
and the domain mismatch error listed above is returned.

From the argument vectors, the internal vectors and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \ \forall \ i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item If {\sf mask} $\ne$ {\sf GrB\_NULL},  
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then
            $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \} \rangle$,
            \item Otherwise, $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \wedge
            ({\sf bool}){\sf mask}(i) = \true \} \rangle$.
        \end{enumerate}

		\item	If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
\end{enumerate}

The internal vectors and masks are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$
    \item $\bold{size}(\vector{\widetilde{u}}) = \bold{size}(\vector{\widetilde{w}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the apply and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
    \item $\vector{\widetilde{t}}$: The vector holding the result from applying the unary operator to the input vector
    $\vector{\widetilde{u}}$.
    \item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

The intermediate vector, $\vector{\widetilde{t}}$, is created as follows:
\[
\vector{\widetilde{t}} = \langle
\bDout({\sf op}), \bold{size}(\vector{\widetilde{u}}),
\{(i,f(\vector{\widetilde{u}}(i))) \forall i \in \bold{ind}(\vector{\widetilde{u}}) \} \rangle, 
\]
where $f = \mathbf{f}({\sf op})$.

\input{ops_accum_z_vector}

\input{ops_mask_replace_vector}


%--------------------------------------------------------------

\subsubsection{{\sf apply}: Matrix variant}
Computes the transformation of the values of the elements of a matrix using a unary function.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Matrix            C,
                           const GrB_Matrix      Mask,
                           const GrB_BinaryOp    accum,
                           const GrB_UnaryOp     op,
                           const GrB_Matrix      A,
                           const GrB_Descriptor  desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS matrix. On input,
    the matrix provides values that may be accumulated with the result of the
    apply operation.  On output, the matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the 
    {\sf Mask} matrix must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf C}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf C} entries.
    If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}] ({\sf IN}) A unary operator applied to each
	    element of input matrix {\sf A}.

    \item[{\sf A}]     ({\sf IN})  The GraphBLAS matrix to which the unary function 
    is applied.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf Mask} matrix. The stored values are not examined.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf Mask}. \\

        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A}
        for the operation. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output matrix {\sf C} is ready to be used in the next method of
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for the operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf Matrix\_dup} for matrix
    parameters).

    \item[{\sf GrB\_DIMENSION\_MISMATCH}] {\sf Mask} and {\sf C}
    dimensions are incompatible, ${\sf nrows} \neq \bold{nrows}({\sf C})$, or 
    ${\sf ncols} \neq \bold{ncols}({\sf C})$.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various matrices are
    incompatible with the corresponding domains of the accumulation operator or 
    unary function, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_apply} computes the result of applying a unary function
to the elements of a 
GraphBLAS matrix: ${\sf C} = f({\sf A})$; or, if an 
optional binary accumulation operator ($\odot$) is provided, 
${\sf C} = {\sf C} \odot f({\sf A})$.  

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[\bf Setup] The internal matrices and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to three argument matrices are used in the {\sf GrB\_apply} operation:
\begin{enumerate}
	\item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),
    \bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$

	\item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),
    \bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)

	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}),
    \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
\end{enumerate}

The argument matrices, unary operator and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
	\item If {\sf Mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf Mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

	\item $\bold{D}({\sf C})$ must be
    compatible with $\bDout({\sf op})$ of the unary operator.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator and 
    $\bDout({\sf op})$ of the unary operator must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.

	\item $\bold{D}({\sf A})$ must be compatible with $\bDinn({\sf op})$ of the unary operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends and 
the domain mismatch error listed above is returned.

From the argument matrices, the internal matrices, mask, and index arrays used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

	\item Two-dimensional mask, $\matrix{\widetilde{M}}$, is computed from 
    argument {\sf Mask} as follows:
	\begin{enumerate}
		\item If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = 
        \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), 
        \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < 
        \bold{ncols}({\sf C}) \} \rangle$.

		\item If {\sf Mask} $\ne$ {\sf GrB\_NULL},
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then 
            $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \} \rangle$,
            \item Otherwise, $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \\ \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \wedge 
            ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.
        \end{enumerate}

		\item	If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.
	\end{enumerate}

	\item Matrix $\matrix{\widetilde{A}} \leftarrow
    {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$.
    
\end{enumerate}

The internal matrices and mask are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})$.

    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{A}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{A}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can optionally exit
with {\sf GrB\_SUCCESS} return code and defer any computation and/or execution error codes.

We are now ready to carry out the apply and any additional 
associated operations.  We describe this in terms of two intermediate matrices:
\begin{itemize}
    \item $\matrix{\widetilde{T}}$: The matrix holding the result from applying the unary operator to the input matrix
    $\matrix{\widetilde{A}}$.

    \item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

The intermediate matrix, $\matrix{\widetilde{T}}$, is created as follows:
\[
\begin{aligned}
\matrix{\widetilde{T}} = & \langle \bDout({\sf op}),
                           \bold{nrows}(\matrix{\widetilde{C}}), 
                           \bold{ncols}(\matrix{\widetilde{C}}),
	\{(i,j,f(\matrix{\widetilde{A}}(i,j))) 
\ \forall \ (i,j) \in 
\bold{ind}(\matrix{\widetilde{A}}) \} \rangle,
\end{aligned}
\]
where $f = \mathbf{f}({\sf op})$.

\input{ops_accum_z_matrix}

\input{ops_mask_replace_matrix}

%-----------------------------------------------------------------------------

\subsubsection{{\sf apply}: Vector-BinaryOp variants}

Computes the transformation of the values of the stored elements of a vector
using a binary operator and a scalar value. In the {\em bind-first} variant, the 
specified scalar value is passed as the first argument to the binary operator and
stored elements of the vector are passed as the second argument.  In the {\em
bind-second} variant, the elements of the vector are passed as the first 
argument and the specified scalar value is passed as the second argument.
The scalar can be passed either as a non-opaque variable or as
a {\sf GrB\_Scalar} object.

\paragraph{\syntax}

\begin{verbatim}
        // bind-first + scalar value
        GrB_Info GrB_apply(GrB_Vector             w,
                           const GrB_Vector       mask,
                           const GrB_BinaryOp     accum,
                           const GrB_BinaryOp     op,
                           <type>                 val,
                           const GrB_Vector       u,
                           const GrB_Descriptor   desc);
\end{verbatim}

\begin{verbatim}
        // bind-first + GraphBLAS scalar
        GrB_Info GrB_apply(GrB_Vector             w,
                           const GrB_Vector       mask,
                           const GrB_BinaryOp     accum,
                           const GrB_BinaryOp     op,
                           const GrB_Scalar       s,
                           const GrB_Vector       u,
                           const GrB_Descriptor   desc);
\end{verbatim}

\begin{verbatim}
        // bind-second + scalar value
        GrB_Info GrB_apply(GrB_Vector             w,
                           const GrB_Vector       mask,
                           const GrB_BinaryOp     accum,
                           const GrB_BinaryOp     op,
                           const GrB_Vector       u,
                           <type>                 val,
                           const GrB_Descriptor   desc);
\end{verbatim}
                           
\begin{verbatim}
        // bind-second + GraphBLAS scalar
        GrB_Info GrB_apply(GrB_Vector             w,
                           const GrB_Vector       mask,
                           const GrB_BinaryOp     accum,
                           const GrB_BinaryOp     op,
                           const GrB_Vector       u,
                           const GrB_Scalar       s,
                           const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    apply operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector {\sf w}. The 
    mask dimensions must match those of the vector {\sf w}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the
    {\sf mask} vector must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf w}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf w} entries. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]	({\sf IN}) A binary operator applied to each element of input 
    vector, {\sf u}, and the scalar value, {\sf val}.
        
    \item[{\sf u}] ({\sf IN}) The GraphBLAS vector whose elements are passed 
    to the binary operator as the right-hand (second) argument in the 
    {\em bind-first} variant, or the left-hand (first) argument in the 
    {\em bind-second} variant.

    \item[{\sf val}] ({\sf IN}) Scalar value that is passed to the binary operator 
    as the left-hand (first) argument in the {\em bind-first} variant, or 
    the right-hand (second) argument in the {\em bind-second} variant.

    \item[{\sf s}] ({\sf IN}) A GraphBLAS scalar that is passed to the binary operator 
    as the left-hand (first) argument in the {\em bind-first} variant, or 
    the right-hand (second) argument in the {\em bind-second} variant.  It must not be empty.
    
    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf mask} vector. The stored values are not examined.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).

    \item[{\sf GrB\_DIMENSION\_MISMATCH}]  {\sf mask}, {\sf w} and/or {\sf u}
    dimensions are incompatible.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various vectors and 
    scalar are incompatible with the corresponding domains of the binary operator or
    accumulation operator, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).

    \item[{\sf GrB\_EMPTY\_OBJECT}] The {\sf GrB\_Scalar} {\sf s} used in the call
	is empty ($\mathbf{nvals}({\sf s}) = 0$) and therefore a value
	cannot be passed to the binary operator.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_apply} computes the result of applying a binary operator
to the elements of a GraphBLAS vector each composed with a scalar constant, either {\sf val} or {\sf s}:
\begin{itemize}[leftmargin=2.1in]
\item[bind-first:~~~~]  ${\sf w} = f({\sf val}, {\sf u})$ or ${\sf w} = f({\sf s}, {\sf u})$
\item[bind-second:~~~~] ${\sf w} = f({\sf u}, {\sf val})$ or ${\sf w} = f({\sf u}, {\sf s})$,
\end{itemize}
or if an optional binary accumulation operator ($\odot$) is provided:
\begin{itemize}[leftmargin=2.1in]
\item[bind-first:~~~~]  ${\sf w} = {\sf w} \odot f({\sf val}, {\sf u})$ or ${\sf w} = {\sf w} \odot f({\sf s}, {\sf u})$ 
\item[bind-second:~~~~] ${\sf w} = {\sf w} \odot f({\sf u}, {\sf val})$ or ${\sf w} = {\sf w} \odot f({\sf u}, {\sf s})$.  
\end{itemize}

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to three argument vectors are used in this {\sf GrB\_apply} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),
    \bold{L}({\sf w}) = \{(i,w_i) \} \rangle$

	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),
    \bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)

	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),
    \bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The argument scalar, vectors, binary operator and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
	\item If {\sf mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

	\item $\bold{D}({\sf w})$ must be compatible with $\bDout({\sf op})$ of the binary operator.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator and 
    $\bDout({\sf op})$ of the binary operator must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.

	\item $\bold{D}({\sf u})$ must be compatible with $\bDin1({\sf op})$ of the binary operator.

	\item If bind-first:
	    \begin{enumerate}

		\item $\bold{D}({\sf u})$ must be compatible with $\bDin2({\sf op})$ of the binary operator.
	    
		\item If the non-opaque scalar {\sf val} is provided, then $\bold{D}({\sf val})$ must be compatible with $\bDin1({\sf op})$ of the binary operator.

		\item If the {\sf GrB\_Scalar} {\sf s} is provided, then $\bold{D}({\sf s})$ must be compatible with $\bDin1({\sf op})$ of the binary operator.

	    \end{enumerate}

	\item If bind-second:
	    \begin{enumerate}

		\item $\bold{D}({\sf u})$ must be compatible with $\bDin1({\sf op})$ of the binary operator.
	    
		\item If the non-opaque scalar {\sf val} is provided, then $\bold{D}({\sf val})$ must be compatible with $\bDin2({\sf op})$ of the binary operator.

		\item If the {\sf GrB\_Scalar} {\sf s} is provided, then $\bold{D}({\sf s})$ must be compatible with $\bDin2({\sf op})$ of the binary operator.

	    \end{enumerate}
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends
and the domain mismatch error listed above is returned.

From the argument vectors, the internal vectors and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \ \forall \ i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item If {\sf mask} $\ne$ {\sf GrB\_NULL},  
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then
            $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \} \rangle$,
            \item Otherwise, $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \wedge
            ({\sf bool}){\sf mask}(i) = \true \} \rangle$.
        \end{enumerate}

		\item	If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.

    \item Scalar $\scalar{\tilde{s}} \leftarrow {\sf s}$ (GraphBLAS scalar case).
\end{enumerate}

The internal vectors and masks are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$
    \item $\bold{size}(\vector{\widetilde{u}}) = \bold{size}(\vector{\widetilde{w}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

If an empty {\sf GrB\_Scalar} $\scalar{\tilde{s}}$ is provided ($\mathbf{nvals}(\scalar{\tilde{s}}) = 0$),
the method returns with code {\sf GrB\_EMPTY\_OBJECT}. If a non-empty {\sf GrB\_Scalar}, 
$\scalar{\tilde{s}}$, is provided (\ie, $\mathbf{nvals}(\scalar{\tilde{s}}) = 1$), we then create an internal variable 
{\sf val} with the same domain as $\scalar{\tilde{s}}$ and set ${\sf val} = \mathbf{val}(\scalar{\tilde{s}})$.

We are now ready to carry out the apply and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
    \item $\vector{\widetilde{t}}$: The vector holding the result from applying the binary operator to the input vector
    $\vector{\widetilde{u}}$.
    \item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

The intermediate vector, $\vector{\widetilde{t}}$, is created as one of the following:
\begin{itemize}[leftmargin=1.5in]
\item[bind-first:~~~~]
$\vector{\widetilde{t}} = \langle
\bDout({\sf op}), \bold{size}(\vector{\widetilde{u}}),
\{(i,f({\sf val},\vector{\widetilde{u}}(i))) \forall i \in \bold{ind}(\vector{\widetilde{u}}) \} \rangle,$

\item[bind-second:~~~~]
$\vector{\widetilde{t}} = \langle
\bDout({\sf op}), \bold{size}(\vector{\widetilde{u}}),
\{(i,f(\vector{\widetilde{u}}(i),{\sf val})) \forall i \in \bold{ind}(\vector{\widetilde{u}}) \} \rangle,$
\end{itemize}
where $f = \mathbf{f}({\sf op})$.

\input{ops_accum_z_vector}

\input{ops_mask_replace_vector}


%--------------------------------------------------------------

\subsubsection{{\sf apply}: Matrix-BinaryOp variants}

Computes the transformation of the values of the stored elements of a matrix
using a binary operator and a scalar value. In the {\em bind-first} variant, the 
specified scalar value is passed as the first argument to the binary operator and
stored elements of the matrix are passed as the second argument.  In the {\em
bind-second} variant, the elements of the matrix are passed as the first 
argument and the specified scalar value is passed as the second argument.
The scalar can be passed either as a non-opaque variable or as
a {\sf GrB\_Scalar} object.

\paragraph{\syntax}

\begin{verbatim}
        // bind-first + scalar value
        GrB_Info GrB_apply(GrB_Matrix            C,
                           const GrB_Matrix      Mask,
                           const GrB_BinaryOp    accum,
                           const GrB_BinaryOp    op,
                           <type>                val,
                           const GrB_Matrix      A,
                           const GrB_Descriptor  desc);
\end{verbatim}

\begin{verbatim}
        // bind-first + GraphBLAS scalar
        GrB_Info GrB_apply(GrB_Matrix            C,
                           const GrB_Matrix      Mask,
                           const GrB_BinaryOp    accum,
                           const GrB_BinaryOp    op,
                           const GrB_Scalar      s,
                           const GrB_Matrix      A,
                           const GrB_Descriptor  desc);
\end{verbatim}

\begin{verbatim}
        // bind-second + scalar value
        GrB_Info GrB_apply(GrB_Matrix            C,
                           const GrB_Matrix      Mask,
                           const GrB_BinaryOp    accum,
                           const GrB_BinaryOp    op,
                           const GrB_Matrix      A,
                           <type>                val,
                           const GrB_Descriptor  desc);
\end{verbatim}

\begin{verbatim}
        // bind-second + GraphBLAS scalar
        GrB_Info GrB_apply(GrB_Matrix            C,
                           const GrB_Matrix      Mask,
                           const GrB_BinaryOp    accum,
                           const GrB_BinaryOp    op,
                           const GrB_Matrix      A,
                           const GrB_Scalar      s,
                           const GrB_Descriptor  desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS matrix. On input,
    the matrix provides values that may be accumulated with the result of the
    apply operation.  On output, the matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the 
    {\sf Mask} matrix must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf C}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf C} entries. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}] ({\sf IN}) A binary operator applied to each element of input 
    matrix, {\sf A}, with the element of the input matrix used as the left-hand 
    argument, and the scalar value, {\sf val}, used as the right-hand argument.

    \item[{\sf A}] ({\sf IN})  The GraphBLAS matrix whose elements are passed 
    to the binary operator as the right-hand (second) argument in the 
    {\em bind-first} variant, or the left-hand (first) argument in the 
    {\em bind-second} variant.

    \item[{\sf val}] ({\sf IN}) Scalar value that is passed to the binary operator 
    as the left-hand (first) argument in the {\em bind-first} variant, or 
    the right-hand (second) argument in the {\em bind-second} variant.
    
    \item[{\sf s}] ({\sf IN}) GraphBLAS scalar value that is passed to the binary operator 
    as the left-hand (first) argument in the {\em bind-first} variant, or 
    the right-hand (second) argument in the {\em bind-second} variant.  It must not be empty.
    
    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf Mask} matrix. The stored values are not examined.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf Mask}. \\

        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A}
        for the operation ({\em bind-second} variant only). \\

        {\sf A}    & {\sf GrB\_INP1} & {\sf GrB\_TRAN}   & Use transpose of {\sf A}
        for the operation ({\em bind-first} variant only). \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output matrix {\sf C} is ready to be used in the next method of
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for the operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf Matrix\_dup} for matrix
    parameters).

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf row\_indices} 
    is greater than or equal to $\bold{nrows}({\sf A})$, or a value in 
    {\sf col\_indices} is greater than or equal to $\bold{ncols}({\sf A})$.  In 
    non-blocking mode, this can be reported as an execution error.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] {\sf Mask} and {\sf C}
    dimensions are incompatible, ${\sf nrows} \neq \bold{nrows}({\sf C})$, or 
    ${\sf ncols} \neq \bold{ncols}({\sf C})$.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various matrices and
    scalar are incompatible with the corresponding domains of the binary operator or
    accumulation operator, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).

    \item[{\sf GrB\_EMPTY\_OBJECT}] The {\sf GrB\_Scalar} {\sf s} used in the call
	is empty ($\mathbf{nvals}({\sf s}) = 0$) and therefore a value
	cannot be passed to the binary operator.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_apply} computes the result of applying a binary operator
to the elements of a GraphBLAS matrix each composed with a scalar constant, {\sf val} or {\sf s}:   
\begin{itemize}[leftmargin=2.1in]
\item[bind-first:~~~~]  ${\sf C} = f({\sf val}, {\sf A})$ or ${\sf C} = f({\sf s}, {\sf A})$
\item[bind-second:~~~~] ${\sf C} = f({\sf A}, {\sf val})$ or ${\sf C} = f({\sf A}, {\sf s})$,
\end{itemize}
or if an optional binary accumulation operator ($\odot$) is provided:  
\begin{itemize}[leftmargin=2.1in]
\item[bind-first:~~~~]  ${\sf C} = {\sf C} \odot f({\sf val}, {\sf A})$ or ${\sf C} = {\sf C} \odot f({\sf s}, {\sf A})$
\item[bind-second:~~~~] ${\sf C} = {\sf C} \odot f({\sf A}, {\sf val})$ or ${\sf C} = {\sf C} \odot f({\sf A}, {\sf s})$.  
\end{itemize}

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[\bf Setup] The internal matrices and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to three argument matrices are used in the {\sf GrB\_apply} operation:
\begin{enumerate}
	\item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),
    \bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$

	\item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),
    \bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)

	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}),
    \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
\end{enumerate}

The argument scalar, matrices, binary operator and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
	\item If {\sf Mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf Mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

	\item $\bold{D}({\sf C})$ must be
    compatible with $\bDout({\sf op})$ of the binary operator.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator and 
    $\bDout({\sf op})$ of the binary operator must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.

	\item $\bold{D}({\sf A})$ must be compatible with $\bDin1({\sf op})$ of the binary operator.

	\item If bind-first:
	    \begin{enumerate}

		\item $\bold{D}({\sf A})$ must be compatible with $\bDin2({\sf op})$ of the binary operator.
	    
		\item If the non-opaque scalar {\sf val} is provided, then $\bold{D}({\sf val})$ must be compatible with $\bDin1({\sf op})$ of the binary operator.

		\item If the {\sf GrB\_Scalar} {\sf s} is provided, then $\bold{D}({\sf s})$ must be compatible with $\bDin1({\sf op})$ of the binary operator.

	    \end{enumerate}

	\item If bind-second:
	    \begin{enumerate}

		\item $\bold{D}({\sf A})$ must be compatible with $\bDin1({\sf op})$ of the binary operator.
	    
		\item If the non-opaque scalar {\sf val} is provided, then $\bold{D}({\sf val})$ must be compatible with $\bDin2({\sf op})$ of the binary operator.

		\item If the {\sf GrB\_Scalar} {\sf s} is provided, then $\bold{D}({\sf s})$ must be compatible with $\bDin2({\sf op})$ of the binary operator.

	    \end{enumerate}
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends and 
the domain mismatch error listed above is returned.

From the argument matrices, the internal matrices, mask, and index arrays used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

	\item Two-dimensional mask, $\matrix{\widetilde{M}}$, is computed from 
    argument {\sf Mask} as follows:
	\begin{enumerate}
		\item If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = 
        \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), 
        \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < 
        \bold{ncols}({\sf C}) \} \rangle$.

		\item If {\sf Mask} $\ne$ {\sf GrB\_NULL},
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then 
            $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \} \rangle$,
            \item Otherwise, $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \\ \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \wedge 
            ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.
        \end{enumerate}

		\item	If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.
	\end{enumerate}

	\item Matrix $\matrix{\widetilde{A}}$ is computed from argument {\sf A} as 
    follows: 
    \begin{itemize}[leftmargin=1.2in]
    \item[bind-first:~~~~]  $\matrix{\widetilde{A}}\leftarrow
        {\sf desc[GrB\_INP1].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$
    \item[bind-second:~~~~] $\matrix{\widetilde{A}}\leftarrow
        {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$
    \end{itemize}
    
    \item Scalar $\scalar{\tilde{s}} \leftarrow {\sf s}$ (GraphBLAS scalar case).
\end{enumerate}

The internal matrices and mask are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})$.

    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{A}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{A}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can optionally exit
with {\sf GrB\_SUCCESS} return code and defer any computation and/or execution error codes.

If an empty {\sf GrB\_Scalar} $\scalar{\tilde{s}}$ is provided ($\mathbf{nvals}(\scalar{\tilde{s}}) = 0$),
the method returns with code {\sf GrB\_EMPTY\_OBJECT}. If a non-empty {\sf GrB\_Scalar}, 
$\scalar{\tilde{s}}$, is provided (\ie, $\mathbf{nvals}(\scalar{\tilde{s}}) = 1$), we then create an internal variable 
{\sf val} with the same domain as $\scalar{\tilde{s}}$ and set ${\sf val} = \mathbf{val}(\scalar{\tilde{s}})$.

We are now ready to carry out the apply and any additional 
associated operations.  We describe this in terms of two intermediate matrices:
\begin{itemize}
    \item $\matrix{\widetilde{T}}$: The matrix holding the result from applying the binary operator to the input matrix
    $\matrix{\widetilde{A}}$.

    \item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

The intermediate matrix, $\matrix{\widetilde{T}}$, is created as one of the following:
\begin{itemize}[leftmargin=1.2in]
\item[bind-first:~~]
$
\begin{aligned}
\matrix{\widetilde{T}} = & \langle \bDout({\sf op}),
                           \bold{nrows}(\matrix{\widetilde{C}}), 
                           \bold{ncols}(\matrix{\widetilde{C}}),
	\{(i,j,f({\sf val},\matrix{\widetilde{A}}(i,j))) 
\ \forall \ (i,j) \in 
\bold{ind}(\matrix{\widetilde{A}}) \} \rangle,
\end{aligned}
$
\item[bind-second:~~]
$
\begin{aligned}
\matrix{\widetilde{T}} = & \langle \bDout({\sf op}),
                           \bold{nrows}(\matrix{\widetilde{C}}), 
                           \bold{ncols}(\matrix{\widetilde{C}}),
	\{(i,j,f(\matrix{\widetilde{A}}(i,j),{\sf val})) 
\ \forall \ (i,j) \in 
\bold{ind}(\matrix{\widetilde{A}}) \} \rangle,
\end{aligned}
$
\end{itemize}
where $f = \mathbf{f}({\sf op})$.

\input{ops_accum_z_matrix}

\input{ops_mask_replace_matrix}

%-----------------------------------------------------------------------------

\subsubsection{{\sf apply}: Vector index unary operator variant}

Computes the transformation of the values of the stored elements of a vector
using an index unary operator that is a function of the stored value, its location 
indices, and an user provided scalar value.
The scalar can be passed either as a non-opaque variable or as
a {\sf GrB\_Scalar} object.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Vector              w,
                           const GrB_Vector        mask,
                           const GrB_BinaryOp      accum,
                           const GrB_IndexUnaryOp  op,
                           const GrB_Vector        u,
                           <type>                  val,
                           const GrB_Descriptor    desc);
\end{verbatim}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Vector              w,
                           const GrB_Vector        mask,
                           const GrB_BinaryOp      accum,
                           const GrB_IndexUnaryOp  op,
                           const GrB_Vector        u,
                           const GrB_Scalar	       s,
                           const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    apply operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector {\sf w}. The 
    mask dimensions must match those of the vector {\sf w}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the
    {\sf mask} vector must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf w}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf w} entries. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}] ({\sf IN}) An index unary operator, 
    $F_i = \langle \Dout, \Din1, \mathbf{D}({\sf GrB\_Index}), \Din2, f_{i} \rangle$, 
    applied to each element stored in the input vector, {\sf u}. It is a function 
    of the stored element's value, its location index,
    and a user supplied scalar value (either {\sf s} or {\sf val}).

    \item[{\sf u}] ({\sf IN}) The GraphBLAS vector whose elements are passed 
    to the index unary operator.

    \item[{\sf val}] ({\sf IN}) An additional scalar value that is passed to the 
    index unary operator.
    
    \item[{\sf s}] ({\sf IN}) An additional GraphBLAS scalar that is passed to the 
    index unary operator.  It must not be empty.
    
    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf mask} vector. The stored values are not examined.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.2in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
	has not been initialized by a call to {\sf new} (or another constructor).

    \item[{\sf GrB\_DIMENSION\_MISMATCH}]  {\sf mask}, {\sf w} and/or {\sf u}
    dimensions are incompatible.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various vectors are
    incompatible with the corresponding domains of the accumulation operator
    or index unary operator, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).

    \item[{\sf GrB\_EMPTY\_OBJECT}] The {\sf GrB\_Scalar} {\sf s} used in the call
	is empty ($\mathbf{nvals}({\sf s}) = 0$) and therefore a value
	cannot be passed to the index unary operator.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_apply} computes the result of applying an index unary operator
to the elements of a GraphBLAS vector each composed with the element's index and 
a scalar constant, {\sf val} or {\sf s}:
\begin{itemize}[leftmargin=2.1in]
    \item[~] ${\sf w} = f_{i}({\sf u}, \bold{ind}({\sf u}), 0, {\sf val})$ or ${\sf w} = f_{i}({\sf u}, \bold{ind}({\sf u}), 0, {\sf s})$,
\end{itemize}
or if an optional binary accumulation operator ($\odot$) is provided:
\begin{itemize}[leftmargin=2.1in]
    \item[~] ${\sf w} = {\sf w} \odot f_{i}({\sf u}, \bold{ind}({\sf u}), 0, {\sf val})$ or ${\sf w} = {\sf w} \odot f_{i}({\sf u}, \bold{ind}({\sf u}), 0, {\sf s})$.
\end{itemize}

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to three argument vectors are used in this {\sf GrB\_apply} operation:
\begin{enumerate}
    \item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),
    \bold{L}({\sf w}) = \{(i,w_i) \} \rangle$

    \item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),
    \bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)

    \item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),
    \bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The argument scalar, vectors, index unary operator and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
    \item If {\sf mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

    \item $\bold{D}({\sf w})$ must be compatible with $\bDout({\sf op})$ of the index unary operator.

    \item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator and 
    $\bDout({\sf op})$ of the index unary operator must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.

    \item $\bold{D}({\sf u})$ must be compatible with $\bDin1({\sf op})$ of the index unary operator.
    
    \item If the non-opaque scalar {\sf val} is provided, then $\bold{D}({\sf val})$ must be compatible with $\bDin2({\sf op})$ of the index unary operator.

    \item If the {\sf GrB\_Scalar} {\sf s} is provided, then $\bold{D}({\sf s})$ must be compatible with $\bDin2({\sf op})$ of the index unary operator.
\end{enumerate}

Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends
and the domain mismatch error listed above is returned.

From the argument vectors, the internal vectors and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
    \item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

    \item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
    \begin{enumerate}
        \item If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \ \forall \ i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

        \item If {\sf mask} $\ne$ {\sf GrB\_NULL},  
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then
            $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \} \rangle$,
            \item Otherwise, $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \wedge
            ({\sf bool}){\sf mask}(i) = \true \} \rangle$.
        \end{enumerate}

        \item    If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
    \end{enumerate}

    \item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
    
    \item Scalar $\scalar{\tilde{s}} \leftarrow {\sf s}$ (GraphBLAS scalar case).
\end{enumerate}

The internal vectors and masks are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
    \item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$
    \item $\bold{size}(\vector{\widetilde{u}}) = \bold{size}(\vector{\widetilde{w}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

If an empty {\sf GrB\_Scalar} $\scalar{\tilde{s}}$ is provided ($\mathbf{nvals}(\scalar{\tilde{s}}) = 0$),
the method returns with code {\sf GrB\_EMPTY\_OBJECT}. If a non-empty {\sf GrB\_Scalar}, 
$\scalar{\tilde{s}}$, is provided ($\mathbf{nvals}(\scalar{\tilde{s}}) = 1$), we then create an internal variable 
{\sf val} with the same domain as $\scalar{\tilde{s}}$ and set ${\sf val} = \mathbf{val}(\scalar{\tilde{s}})$.

We are now ready to carry out the apply and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
    \item $\vector{\widetilde{t}}$: The vector holding the result from applying the index unary operator to the input vector
    $\vector{\widetilde{u}}$.
    \item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

The intermediate vector, $\vector{\widetilde{t}}$, is created as follows:
\[
\vector{\widetilde{t}} = \langle
\bDout({\sf op}), \bold{size}(\vector{\widetilde{u}}),
\{(i,f_{i}(\vector{\widetilde{u}}(i),[i],0,{\sf val})) \forall i \in \bold{ind}(\vector{\widetilde{u}}) \} \rangle,
\]
where $f_{i} = \mathbf{f}({\sf op})$.

\input{ops_accum_z_vector}

\input{ops_mask_replace_vector}

%-----------------------------------------------------------------------------

\subsubsection{{\sf apply}: Matrix index unary operator variant}

Computes the transformation of the values of the stored elements of a matrix
using an index unary operator that is a function of the stored value, its location 
indices, and an user provided scalar value.
The scalar can be passed either as a non-opaque variable or as
a {\sf GrB\_Scalar} object.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Matrix              C,
                           const GrB_Matrix        Mask,
                           const GrB_BinaryOp      accum,
                           const GrB_IndexUnaryOp  op,
                           const GrB_Matrix        A,
                           <type>                  val,
                           const GrB_Descriptor    desc);
\end{verbatim}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Matrix              C,
                           const GrB_Matrix        Mask,
                           const GrB_BinaryOp      accum,
                           const GrB_IndexUnaryOp  op,
                           const GrB_Matrix        A,
                           const GrB_Scalar	       s,
                           const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS matrix. On input,
    the matrix provides values that may be accumulated with the result of the
    apply operation.  On output, the matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the 
    {\sf Mask} matrix must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf C}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf C} entries. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}] ({\sf IN}) An index unary operator, 
    $F_i = \langle \Dout, \Din1, \mathbf{D}({\sf GrB\_Index}), \Din2, f_{i} \rangle$, 
    applied to each element stored in the input matrix, {\sf A}. It is a function 
    of the stored element's value, its row and column indices,
    and a user supplied scalar value (either {\sf s} or {\sf val}).

    \item[{\sf A}] ({\sf IN}) The GraphBLAS matrix whose elements are passed 
    to the index unary operator.

    \item[{\sf val}] ({\sf IN}) An additional scalar value that is passed to the 
    index unary operator.

    \item[{\sf s}] ({\sf IN}) An additional GraphBLAS scalar that is passed to the 
    index unary operator.
    
    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf Mask} matrix. The stored values are not examined.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf Mask}. \\

        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A}
        for the operation. \\
    \end{tabular}
\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output matrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or another constructor).

    \item[{\sf GrB\_DIMENSION\_MISMATCH}]  {\sf mask}, {\sf w} and/or {\sf u}
    dimensions are incompatible.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various matrices are
    incompatible with the corresponding domains of the accumulation operator
    or index unary operator, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).

    \item[{\sf GrB\_EMPTY\_OBJECT}] The {\sf GrB\_Scalar} {\sf s} used in the call
	is empty ($\mathbf{nvals}({\sf s}) = 0$) and therefore a value
	cannot be passed to the index unary operator.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_apply} computes the result of applying a index unary operator
to the elements of a GraphBLAS matrix each composed with the elements row and column
indices, and a scalar constant, {\sf val} or {\sf s}:   
\begin{itemize}
    \item[~] ${\sf C} = f_{i}({\sf A}, \bold{row}(\bold{ind}({\sf A})), \bold{col}(\bold{ind}({\sf A})), {\sf val})$ or  ${\sf C} = f_{i}({\sf A}, \bold{row}(\bold{ind}({\sf A})), \bold{col}(\bold{ind}({\sf A})), {\sf s})$,
\end{itemize}
or if an optional binary accumulation operator ($\odot$) is provided:  
\begin{itemize}
    \item[~] ${\sf C} = {\sf C} \odot f_{i}({\sf A}, \bold{row}(\bold{ind}({\sf A})), \bold{col}(\bold{ind}({\sf A})), {\sf val})$ or ${\sf C} = {\sf C} \odot f_{i}({\sf A}, \bold{row}(\bold{ind}({\sf A})), \bold{col}(\bold{ind}({\sf A})), {\sf s})$.  
\end{itemize}
Where the $\bold{row}$ and $\bold{col}$ functions extract the row and column indices from a list of two-dimensional indices, respectively.

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[\bf Setup] The internal matrices and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to three argument matrices are used in the {\sf GrB\_apply} operation:
\begin{enumerate}
    \item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),
    \bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$

    \item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),
    \bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)

    \item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}),
    \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
\end{enumerate}

The argument scalar, matrices, index unary operator and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
    \item If {\sf Mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf Mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

    \item $\bold{D}({\sf C})$ must be
    compatible with $\bDout({\sf op})$ of the index unary operator. 

    \item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator and 
    $\bDout({\sf op})$ of the index unary operator must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.

    \item $\bold{D}({\sf A})$ must be compatible with $\bDin1({\sf op})$ of the index unary operator.
    
    \item If the non-opaque scalar {\sf val} is provided, then $\bold{D}({\sf val})$ must be compatible with $\bDin2({\sf op})$ of the index unary operator.

    \item If the {\sf GrB\_Scalar} {\sf s} is provided, then $\bold{D}({\sf s})$ must be compatible with $\bDin2({\sf op})$ of the index unary operator.
\end{enumerate}

Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends and 
the domain mismatch error listed above is returned.

From the argument matrices, the internal matrices, mask, and index arrays used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
    \item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

    \item Two-dimensional mask, $\matrix{\widetilde{M}}$, is computed from 
    argument {\sf Mask} as follows:
    \begin{enumerate}
        \item If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = 
        \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), 
        \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < 
        \bold{ncols}({\sf C}) \} \rangle$.

        \item If {\sf Mask} $\ne$ {\sf GrB\_NULL},
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then 
            $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \} \rangle$,
            \item Otherwise, $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \\ \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \wedge 
            ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.
        \end{enumerate}

        \item    If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.
    \end{enumerate}

    \item Matrix $\matrix{\widetilde{A}}$ is computed from argument {\sf A} as 
    follows: 
    \begin{itemize}[leftmargin=1.2in]
%    \item[bind-first:~~~~]  $\matrix{\widetilde{A}}\leftarrow
%        {\sf desc[GrB\_INP1].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$
%    \item[bind-second:~~~~]
	\item[~] $\matrix{\widetilde{A}}\leftarrow {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$
    \end{itemize}

    \item Scalar $\scalar{\tilde{s}} \leftarrow {\sf s}$ (GraphBLAS scalar case).
\end{enumerate}

The internal matrices and mask are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})$.

    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{A}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{A}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can optionally exit
with {\sf GrB\_SUCCESS} return code and defer any computation and/or execution error codes.

If an empty {\sf GrB\_Scalar} $\scalar{\tilde{s}}$ is provided ($\mathbf{nvals}(\scalar{\tilde{s}}) = 0$),
the method returns with code {\sf GrB\_EMPTY\_OBJECT}. If a non-empty {\sf GrB\_Scalar}, 
$\scalar{\tilde{s}}$, is provided (\ie, $\mathbf{nvals}(\scalar{\tilde{s}}) = 1$), we then create an internal variable 
{\sf val} with the same domain as $\scalar{\tilde{s}}$ and set ${\sf val} = \mathbf{val}(\scalar{\tilde{s}})$.

We are now ready to carry out the apply and any additional 
associated operations.  We describe this in terms of two intermediate matrices:
\begin{itemize}
    \item $\matrix{\widetilde{T}}$: The matrix holding the result from applying the index unary operator to the input matrix
    $\matrix{\widetilde{A}}$.

    \item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

The intermediate matrix, $\matrix{\widetilde{T}}$, is created as follows:
\[
\begin{aligned}
\matrix{\widetilde{T}} = & \langle \bDout({\sf op}),
                           \bold{nrows}(\matrix{\widetilde{C}}), 
                           \bold{ncols}(\matrix{\widetilde{C}}),
    \{(i,j,f_{i}(\matrix{\widetilde{A}}(i,j),i,j,{\sf val})) 
\ \forall \ (i,j) \in 
\bold{ind}(\matrix{\widetilde{A}}) \} \rangle,
\end{aligned}
\]
where $f_i = \mathbf{f}({\sf op})$.

\input{ops_accum_z_matrix}

\input{ops_mask_replace_matrix}

